#!/usr/bin/env python3
# Version: 2.24
import argparse
import os
import sys
import re
import urllib.parse
import requests
import shutil
import subprocess
import zipfile
import tempfile
from tqdm import tqdm
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import signal

# Gestionnaire pour interrompre proprement avec Ctrl+C
shutdown_event = threading.Event()

def signal_handler(sig, frame):
    print("\nInterruption détectée, arrêt des téléchargements...")
    shutdown_event.set()
    sys.exit(1)

signal.signal(signal.SIGINT, signal_handler)

# Initialiser le verrou global pour tqdm
tqdm.set_lock(threading.Lock())

# Parse les arguments
parser = argparse.ArgumentParser(description="Télécharge les fichiers Myrient avec options de filtrage et traitement.")
parser.add_argument("url", help="URL de la page Myrient")
parser.add_argument("--fr-only", action="store_true", help="Ne conserve que les versions (France) et (Fr)")
parser.add_argument("--eu-only", action="store_true", help="Ne liste que les jeux avec une version (France), (Fr), (Europe) ou (USA) avec Fr")
parser.add_argument("--all", action="store_true", help="Télécharge tous les fichiers sans filtrer par région")
parser.add_argument("--extract", action="store_true", help="Télécharge le .zip dans /tmp, décompresse dans le dossier final, marque le .zip dans progression.txt après extraction")
parser.add_argument("--chd", action="store_true", help="Télécharge le .zip dans /tmp, décompresse dans /tmp, convertit en .chd dans le dossier final")
parser.add_argument("--max", type=int, default=3, help="Nombre maximum de téléchargements ou traitements simultanés (défaut : 3 pour standard, 1 pour --extract/--chd)")
parser.add_argument("--name", type=str, help="Ne télécharge que les jeux commençant par la chaîne spécifiée (ex: 'ab' pour les jeux commençant par 'ab', '0' pour les chiffres)")
args = parser.parse_args()

URL = args.url
FR_ONLY = args.fr_only
EU_ONLY = args.eu_only
ALL = args.all
EXTRACT = args.extract
CHD = args.chd
MAX_WORKERS_DEFAULT = args.max
NAME_FILTER = args.name

# Vérifie les arguments
if sum([FR_ONLY, EU_ONLY, ALL]) > 1:
    print("Erreur : Les options --fr-only, --eu-only et --all ne peuvent pas être utilisées ensemble.")
    sys.exit(1)
if sum([EXTRACT, CHD]) > 1:
    print("Erreur : Les options --extract et --chd ne peuvent pas être utilisées ensemble.")
    sys.exit(1)
if CHD and shutil.which("chdman") is None:
    print("Erreur : L'outil 'chdman' est requis pour l'option --chd mais n'est pas installé.")
    sys.exit(1)
if MAX_WORKERS_DEFAULT < 1:
    print("Erreur : L'option --max doit être un entier positif (minimum 1).")
    sys.exit(1)
if NAME_FILTER and not re.match(r'^[a-zA-Z0-9]+$', NAME_FILTER):
    print("Erreur : L'option --name doit contenir uniquement des lettres ou des chiffres (ex: 'ab', '0').")
    sys.exit(1)

# Menu interactif si aucune option de filtrage n’est spécifiée
if not (FR_ONLY or EU_ONLY or ALL):
    print("Aucune option de filtrage spécifiée. Veuillez choisir une option :")
    print("1. --eu-only (par défaut)")
    print("2. --fr-only : Jeux uniquement en français")
    print("3. --all : Tous les fichiers sans filtrage par région")
    choice = input("Entrez votre choix (1, 2, 3) ou appuyez sur Entrée pour --eu-only : ").strip()

    if choice == "" or choice == "1":
        EU_ONLY = True
        print("Option choisie : --eu-only")
    elif choice == "2":
        FR_ONLY = True
        print("Option choisie : --fr-only")
    elif choice == "3":
        ALL = True
        print("Option choisie : --all")
    else:
        print("Choix invalide. Utilisation de --eu-only par défaut.")
        EU_ONLY = True

# Détermine le dossier de téléchargement
current_dir = os.path.realpath(os.getcwd())
home_dir = os.path.realpath(os.path.expanduser("~"))
download_dir = current_dir

if current_dir == home_dir:
    try:
        download_dir = subprocess.check_output(["xdg-user-dir", "DOWNLOAD"], text=True).strip()
        print(f"Chemin de téléchargement détecté via xdg-user-dir : {download_dir}")
    except subprocess.CalledProcessError:
        print("Avertissement : Impossible de déterminer le dossier de téléchargements via xdg-user-dir. Utilisation de ~/Downloads comme secours.")
        download_dir = os.path.join(home_dir, "Downloads")
    download_dir = os.path.join(download_dir, "myrientdl")
    os.makedirs(download_dir, exist_ok=True)
    print(f"Téléchargements dans : {download_dir}")
else:
    print(f"Téléchargements dans : {current_dir}")

# Chemins temporaires et fichiers de progression/check
RAW_OUTPUT = "/tmp/raw_download_links.txt"
FILTERED_OUTPUT = os.path.join(download_dir, "filtered_download_links.txt")
PROGRESS_FILE_PATH = os.path.join(download_dir, "progression.txt")
CHECK_FILE_PATH = os.path.join(download_dir, "check.txt")

# Fonction pour lire les fichiers déjà traités dans progression.txt
def read_progress_file(progress_file_path):
    downloaded_files = set()
    if os.path.exists(progress_file_path):
        try:
            with open(progress_file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    downloaded_files.add(line.strip())
        except Exception as e:
            print(f"Erreur lors de la lecture de {progress_file_path}: {e}")
    return downloaded_files

# Fonction pour ajouter un fichier à progression.txt
def append_to_progress_file(progress_file_path, filename):
    try:
        with open(progress_file_path, 'a', encoding='utf-8') as f:
            f.write(f"{filename}\n")
    except Exception as e:
        print(f"Erreur lors de l'écriture dans {progress_file_path}: {e}")

# Fonction pour écrire dans check.txt
def write_check_file(check_file_path, selected_links):
    try:
        with open(check_file_path, 'w', encoding='utf-8') as f:
            f.write("Fichiers à télécharger :\n")
            if selected_links:
                for link in sorted(selected_links):
                    filename = urllib.parse.unquote(os.path.basename(link))
                    f.write(f"- {filename}\n")
            else:
                f.write("Aucun fichier trouvé.\n")
    except Exception as e:
        print(f"Erreur lors de l'écriture dans {check_file_path}: {e}")

# Récupère la page et extrait les liens de fichiers
response = requests.get(URL)
links = re.findall(r'href="([^"]+\.(?:bin|cue|iso|zip|7z|rar))"', response.text)
if not links:
    print("Aucun lien de fichier trouvé.")
    sys.exit(1)

# Stocke les liens bruts temporairement
with open(RAW_OUTPUT, 'w') as f:
    for link in links:
        f.write(f"{URL}{link}\n")

# Vérifie la taille d'un fichier sur le serveur
def get_server_file_size(url):
    try:
        response = requests.head(url, allow_redirects=True, timeout=10)
        if response.status_code == 200:
            return int(response.headers.get("content-length", 0))
        return None
    except requests.RequestException:
        return None

def contains_term(filename, term):
    pattern = r'\b' + re.escape(term) + r'\b'
    return bool(re.search(pattern, filename, re.IGNORECASE))

def get_game_name(filename):
    name = re.sub(r'\s*\([^\)]*\)', '', filename)
    name = re.sub(r'\s*-\s*Disc\s*[0-9]+', '', name)
    name = re.sub(r'\.[a-zA-Z0-9]+$', '', name)
    name = name.lower()
    name = re.sub(r'[^a-z0-9]+', '-', name)
    name = re.sub(r'-+', '-', name)
    return name.strip('-')

def get_disc_num(filename):
    match = re.search(r'Disc\s*([0-9]+)', filename, re.IGNORECASE)
    if match:
        return match.group(1)
    return "0"

# Stocke les versions par jeu et disque, en vérifiant les fichiers existants
game_versions = {}
game_regions = {}
existing_files = {f for f in os.listdir(download_dir) if os.path.isfile(os.path.join(download_dir, f))}
downloaded_files = read_progress_file(PROGRESS_FILE_PATH)
with open(RAW_OUTPUT, 'r') as f:
    for link in f:
        link = link.strip()
        filename = urllib.parse.unquote(os.path.basename(link))

        game_name = get_game_name(filename)
        disc_num = get_disc_num(filename)

        # Vérifier si une version de ce jeu est déjà dans progression.txt
        if EXTRACT or CHD:
            if any(get_game_name(f) == game_name and get_disc_num(f) == disc_num for f in downloaded_files):
                print(f"Une version de {game_name} (disque {disc_num}) est déjà dans progression.txt, ignoré : {filename}")
                continue
        else:
            # Pour le mode standard, vérifier le .zip exact
            if filename in downloaded_files:
                print(f"{filename} déjà marqué comme téléchargé dans progression.txt, ignoré.")
                continue
            # Vérifier si le .zip existe déjà dans download_dir
            if filename in existing_files:
                server_size = get_server_file_size(link)
                local_size = os.path.getsize(os.path.join(download_dir, filename))
                if server_size and local_size == server_size:
                    print(f"{filename} déjà présent avec la bonne taille, marqué comme téléchargé.")
                    append_to_progress_file(PROGRESS_FILE_PATH, filename)
                    continue

        if contains_term(filename, "Demo") or contains_term(filename, "Beta"):
            print(f"{filename} ignoré : contient Demo ou Beta")
            continue

        key = f"{game_name}_disc_{disc_num}"

        if ALL:
            priority = 0
            region = "All"
        else:
            priority = None
            region = None
            if contains_term(filename, "USA") and (contains_term(filename, "Fr,") or contains_term(filename, ",Fr,") or contains_term(filename, ",Fr)")):
                priority = 0
                region = "USA_Fr"
            elif contains_term(filename, "France"):
                priority = 1
                region = "France"
            elif contains_term(filename, "Fr,") or contains_term(filename, ",Fr,") or contains_term(filename, ",Fr)"):
                priority = 2
                region = "Fr"
            elif contains_term(filename, "Europe") and (contains_term(filename, "Fr,") or contains_term(filename, ",Fr,") or contains_term(filename, ",Fr)")):
                priority = 3
                region = "Europe_Fr"
            elif contains_term(filename, "USA"):
                priority = 4
                region = "USA"
            elif contains_term(filename, "Europe"):
                priority = 5
                region = "Europe"
            else:
                continue

        if game_name not in game_regions:
            game_regions[game_name] = set()
        game_regions[game_name].add(region)
        if key not in game_versions or priority < game_versions[key][1]:
            game_versions[key] = (link, priority, filename)

# Filtre les jeux en mode --eu-only
selected_links = []
if EU_ONLY:
    for key, (link, priority, filename) in game_versions.items():
        game_name = key.split('_disc_')[0]
        if any(r in {"France", "Fr", "Europe", "USA_Fr", "USA", "Europe_Fr"} for r in game_regions[game_name]):
            selected_links.append(link)
elif FR_ONLY:
    for key, (link, priority, filename) in game_versions.items():
        game_name = key.split('_disc_')[0]
        if any(r in {"France", "Fr", "USA_Fr", "Europe_Fr"} for r in game_regions[game_name]):
            selected_links.append(link)
else:  # ALL
    selected_links = [version[0] for version in game_versions.values()]

# Filtre supplémentaire basé sur --name
if NAME_FILTER:
    filtered_links = []
    for link in selected_links:
        filename = urllib.parse.unquote(os.path.basename(link))
        if NAME_FILTER.lower() == '0':
            if re.match(r'^\d', filename, re.IGNORECASE):
                filtered_links.append(link)
        else:
            if filename.lower().startswith(NAME_FILTER.lower()):
                filtered_links.append(link)
    selected_links = filtered_links
    if not selected_links:
        print(f"Aucun jeu trouvé commençant par '{NAME_FILTER}' après filtrage.")
        sys.exit(1)

# Écrit dans check.txt
write_check_file(CHECK_FILE_PATH, selected_links)

# Écrit les liens sélectionnés
if selected_links:
    with open(FILTERED_OUTPUT, 'w') as f:
        for link in sorted(selected_links):
            f.write(f"{link}\n")
else:
    print("Aucun lien filtré trouvé.")
    sys.exit(1)

# Lit les liens
with open(FILTERED_OUTPUT, 'r') as f:
    links = [line.strip() for line in f if line.strip()]

# Supprime les fichiers temporaires
os.remove(RAW_OUTPUT)
os.remove(FILTERED_OUTPUT)

# Fonction pour tronquer les noms
def truncate_filename(filename, max_length=15):
    if len(filename) <= max_length:
        return filename
    return filename[:max_length-3] + "..."

# Fonction pour télécharger un fichier avec reprise et barre de progression
def download_file_to_tmp(url, tmp_path, position=0):
    if shutdown_event.is_set():
        return False, url

    filename = urllib.parse.unquote(os.path.basename(url))
    display_name = truncate_filename(filename)

    resume_byte_pos = 0
    if os.path.exists(tmp_path):
        resume_byte_pos = os.path.getsize(tmp_path)
        print(f"{filename} déjà présent dans /tmp, reprise à {resume_byte_pos} octets")

    headers = {"Range": f"bytes={resume_byte_pos}-"} if resume_byte_pos else {}
    try:
        response = requests.get(url, headers=headers, stream=True, timeout=30)
    except requests.RequestException as e:
        print(f"Échec du téléchargement de {filename} : {e}")
        return False, url

    if response.status_code == 416:
        server_size = get_server_file_size(url)
        if server_size and resume_byte_pos >= server_size:
            print(f"{filename} déjà téléchargé dans /tmp (taille complète : {resume_byte_pos} octets)")
            return True, url
        print(f"Échec du téléchargement de {filename} : Requête de reprise invalide")
        return False, url

    if response.status_code not in (200, 206):
        print(f"Échec du téléchargement de {filename} : Statut {response.status_code}")
        return False, url

    total_size = int(response.headers.get("content-length", 0)) + resume_byte_pos
    block_size = 1024

    with tqdm(total=total_size, initial=resume_byte_pos, unit="B", unit_scale=True, desc=display_name, position=position, leave=True, mininterval=0.2, bar_format="{l_bar}{bar}| {n_fmt}/{total_fmt}") as progress_bar:
        with open(tmp_path, "ab" if resume_byte_pos else "wb") as f:
            try:
                for chunk in response.iter_content(chunk_size=block_size):
                    if shutdown_event.is_set():
                        return False, url
                    if chunk:
                        f.write(chunk)
                        progress_bar.update(len(chunk))
            except requests.RequestException as e:
                print(f"Échec du téléchargement de {filename} : {e}")
                return False, url

    server_size = get_server_file_size(url)
    local_size = os.path.getsize(tmp_path)
    if server_size and local_size == server_size:
        print(f"{filename} téléchargé dans /tmp")
        return True, url
    else:
        print(f"Téléchargement de {filename} incomplet (local: {local_size}, serveur: {server_size})")
        return False, url

# Fonction pour décompresser un .zip
def extract_zip(zip_path, dest_dir):
    try:
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(dest_dir)
        print(f"Décompression de {os.path.basename(zip_path)} terminée dans {dest_dir}")
        return True
    except Exception as e:
        print(f"Échec de la décompression de {os.path.basename(zip_path)} : {e}")
        return False

# Fonction pour convertir en .chd avec chdman
def convert_to_chd(cue_or_iso_path, dest_dir, downloaded_files):
    output_chd = os.path.join(dest_dir, os.path.splitext(os.path.basename(cue_or_iso_path))[0] + ".chd")
    chd_filename = os.path.basename(output_chd)

    # Supprimer un .chd partiel s'il existe mais n'est pas dans progression.txt
    if os.path.exists(output_chd) and chd_filename not in downloaded_files:
        print(f"Suppression du .chd partiel : {chd_filename}")
        os.remove(output_chd)

    # Choisir la commande en fonction du type de fichier
    command = ["chdman"]
    if cue_or_iso_path.lower().endswith('.cue'):
        command.append("createcd")
    elif cue_or_iso_path.lower().endswith('.iso'):
        command.append("createdvd")
    else:
        print(f"Format non supporté pour {os.path.basename(cue_or_iso_path)} : doit être .cue ou .iso")
        return False, None

    command.extend(["-i", cue_or_iso_path, "-o", output_chd])

    try:
        result = subprocess.run(command, capture_output=True, text=True, check=True)
        print(f"Conversion de {os.path.basename(cue_or_iso_path)} en {chd_filename} terminée")
        return True, output_chd
    except subprocess.CalledProcessError as e:
        print(f"Échec de la conversion de {os.path.basename(cue_or_iso_path)} : {e.stderr}")
        return False, None
    except Exception as e:
        print(f"Erreur lors de la conversion de {os.path.basename(cue_or_iso_path)} : {e}")
        return False, None

# Fonction principale pour traiter un fichier avec --extract
def process_extract(url, download_dir, position=0):
    filename = urllib.parse.unquote(os.path.basename(url))
    downloaded_files = read_progress_file(PROGRESS_FILE_PATH)
    if filename in downloaded_files:
        print(f"{filename} déjà marqué comme décompressé dans progression.txt, ignoré.")
        return True, url

    tmp_zip = os.path.join("/tmp", f"myrientdl_{os.path.basename(url)}")
    try:
        # Télécharge dans /tmp
        success, _ = download_file_to_tmp(url, tmp_zip, position)
        if not success or shutdown_event.is_set():
            if os.path.exists(tmp_zip):
                os.remove(tmp_zip)
            return False, url

        # Décompresse dans download_dir
        if not extract_zip(tmp_zip, download_dir):
            os.remove(tmp_zip)
            return False, url

        # Marque comme terminé après décompression réussie
        append_to_progress_file(PROGRESS_FILE_PATH, filename)
        print(f"Traitement de {filename} terminé")
        return True, url
    finally:
        if os.path.exists(tmp_zip):
            os.remove(tmp_zip)

# Fonction principale pour traiter un fichier avec --chd
def process_chd(url, download_dir, position=0):
    filename = urllib.parse.unquote(os.path.basename(url))
    downloaded_files = read_progress_file(PROGRESS_FILE_PATH)

    tmp_zip = os.path.join("/tmp", f"myrientdl_{os.path.basename(url)}")
    with tempfile.TemporaryDirectory(prefix="myrientdl_", dir="/tmp") as tmp_extract_dir:
        try:
            # Télécharge dans /tmp
            success, _ = download_file_to_tmp(url, tmp_zip, position)
            if not success or shutdown_event.is_set():
                return False, url

            # Décompresse dans tmp_extract_dir
            if not extract_zip(tmp_zip, tmp_extract_dir):
                return False, url

            # Supprime le .zip immédiatement après extraction pour libérer l'espace
            if os.path.exists(tmp_zip):
                os.remove(tmp_zip)

            # Recherche des fichiers .cue ou .iso
            chd_created = False
            for root, _, files in os.walk(tmp_extract_dir):
                for file in files:
                    if file.lower().endswith(('.cue', '.iso')):
                        cue_or_iso_path = os.path.join(root, file)
                        success, output_chd = convert_to_chd(cue_or_iso_path, download_dir, downloaded_files)
                        if success and output_chd:
                            chd_filename = os.path.basename(output_chd)
                            if chd_filename in downloaded_files:
                                print(f"{chd_filename} déjà marqué comme converti dans progression.txt, ignoré.")
                                continue
                            append_to_progress_file(PROGRESS_FILE_PATH, chd_filename)
                            chd_created = True
                        if not success or shutdown_event.is_set():
                            return False, url

            if not chd_created:
                print(f"Aucun fichier .cue ou .iso trouvé dans {filename}")
                return False, url

            print(f"Traitement de {filename} terminé")
            return True, url
        finally:
            # Nettoyage final (le .zip est déjà supprimé, mais on vérifie au cas où)
            if os.path.exists(tmp_zip):
                os.remove(tmp_zip)

# Fonction pour télécharger un fichier directement
def download_file(url, dest_dir, position=0):
    if shutdown_event.is_set():
        return False, url

    filename = urllib.parse.unquote(os.path.basename(url))
    dest_path = os.path.join(dest_dir, filename)
    display_name = truncate_filename(filename)

    downloaded_files = read_progress_file(PROGRESS_FILE_PATH)
    if filename in downloaded_files:
        print(f"{filename} déjà marqué comme téléchargé dans progression.txt, ignoré.")
        return True, url

    resume_byte_pos = 0
    if os.path.exists(dest_path):
        resume_byte_pos = os.path.getsize(dest_path)
        print(f"{filename} déjà présent, reprise à {resume_byte_pos} octets")

    headers = {"Range": f"bytes={resume_byte_pos}-"} if resume_byte_pos else {}
    try:
        response = requests.get(url, headers=headers, stream=True, timeout=30)
    except requests.RequestException as e:
        print(f"Échec du téléchargement de {filename} : {e}")
        return False, url

    if response.status_code == 416:
        server_size = get_server_file_size(url)
        if server_size and resume_byte_pos >= server_size:
            print(f"{filename} déjà téléchargé (taille complète : {resume_byte_pos} octets)")
            append_to_progress_file(PROGRESS_FILE_PATH, filename)
            return True, url
        print(f"Échec du téléchargement de {filename} : Requête de reprise invalide")
        return False, url

    if response.status_code not in (200, 206):
        print(f"Échec du téléchargement de {filename} : Statut {response.status_code}")
        return False, url

    total_size = int(response.headers.get("content-length", 0)) + resume_byte_pos
    block_size = 1024

    with tqdm(total=total_size, initial=resume_byte_pos, unit="B", unit_scale=True, desc=display_name, position=position, leave=True, mininterval=0.2, bar_format="{l_bar}{bar}| {n_fmt}/{total_fmt}") as progress_bar:
        with open(dest_path, "ab" if resume_byte_pos else "wb") as f:
            try:
                for chunk in response.iter_content(chunk_size=block_size):
                    if shutdown_event.is_set():
                        return False, url
                    if chunk:
                        f.write(chunk)
                        progress_bar.update(len(chunk))
            except requests.RequestException as e:
                print(f"Échec du téléchargement de {filename} : {e}")
                return False, url

    server_size = get_server_file_size(url)
    local_size = os.path.getsize(dest_path)
    if server_size and local_size == server_size:
        print(f"{filename} terminé")
        append_to_progress_file(PROGRESS_FILE_PATH, filename)
        return True, url
    else:
        print(f"Téléchargement de {filename} incomplet (local: {local_size}, serveur: {server_size})")
        return False, url

# Exécution des téléchargements ou traitements
# Ajuster MAX_WORKERS en fonction du mode
MAX_WORKERS = MAX_WORKERS_DEFAULT
if (EXTRACT or CHD) and args.max == 3:  # Utiliser 1 pour --extract/--chd si --max n'est pas spécifié
    MAX_WORKERS = 1

print(f"Lancement du traitement avec maximum {MAX_WORKERS} tâches simultanées...")
try:
    if EXTRACT:
        print("Mode --extract : Téléchargement et décompression...")
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            future_to_url = {executor.submit(process_extract, link, download_dir, i % MAX_WORKERS): link for i, link in enumerate(sorted(links))}
            for future in as_completed(future_to_url):
                if shutdown_event.is_set():
                    executor._threads.clear()
                    executor.shutdown(wait=False)
                    break
                try:
                    success, url = future.result()
                    if not success:
                        print(f"Erreur lors du traitement de {urllib.parse.unquote(os.path.basename(url))}")
                except Exception as e:
                    print(f"Erreur dans le thread pour {urllib.parse.unquote(os.path.basename(future_to_url[future]))} : {e}")
    elif CHD:
        print("Mode --chd : Téléchargement, décompression et conversion en CHD...")
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            future_to_url = {executor.submit(process_chd, link, download_dir, i % MAX_WORKERS): link for i, link in enumerate(sorted(links))}
            for future in as_completed(future_to_url):
                if shutdown_event.is_set():
                    executor._threads.clear()
                    executor.shutdown(wait=False)
                    break
                try:
                    success, url = future.result()
                    if not success:
                        print(f"Erreur lors du traitement de {urllib.parse.unquote(os.path.basename(url))}")
                except Exception as e:
                    print(f"Erreur dans le thread pour {urllib.parse.unquote(os.path.basename(future_to_url[future]))} : {e}")
    else:
        print("Mode standard : Téléchargement des fichiers...")
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            future_to_url = {executor.submit(download_file, link, download_dir, i % MAX_WORKERS): link for i, link in enumerate(sorted(links))}
            for future in as_completed(future_to_url):
                if shutdown_event.is_set():
                    executor._threads.clear()
                    executor.shutdown(wait=False)
                    break
                try:
                    success, url = future.result()
                    if not success:
                        print(f"Erreur lors du téléchargement de {urllib.parse.unquote(os.path.basename(url))}")
                except Exception as e:
                    print(f"Erreur dans le thread pour {urllib.parse.unquote(os.path.basename(future_to_url[future]))} : {e}")
except KeyboardInterrupt:
    shutdown_event.set()
    print("\nTraitement interrompu par l'utilisateur.")
    sys.exit(1)
except Exception as e:
    print(f"Erreur inattendue : {e}")
    sys.exit(1)

if not shutdown_event.is_set():
    print("Tous les traitements terminés.")
