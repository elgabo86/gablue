#!/usr/bin/env python3
# Version: 2.50
import argparse
import os
import sys
import re
import urllib.parse
import requests
import shutil
import subprocess
import zipfile
import tempfile
from tqdm import tqdm
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import signal
import json
import configparser

# Gestionnaire pour interrompre proprement avec Ctrl+C
shutdown_event = threading.Event()

def signal_handler(sig, frame):
    print("\nInterruption détectée, arrêt des téléchargements...")
    shutdown_event.set()
    sys.exit(1)

signal.signal(signal.SIGINT, signal_handler)

# Initialiser le verrou global pour tqdm
tqdm.set_lock(threading.Lock())

# Configuration pour RetroAchievements API
RA_API_BASE_URL = "https://retroachievements.org/API/"
CONFIG_DIR = os.path.expanduser("~/.config/mydl")
CONFIG_FILE = os.path.join(CONFIG_DIR, "login")

# Exception personnalisée pour gérer les erreurs d'authentification
class AuthenticationError(Exception):
    pass

# Parse les arguments
parser = argparse.ArgumentParser(description="Télécharge les fichiers Myrient avec options de filtrage et traitement.")
parser.add_argument("url", nargs='?', help="URL de la page Myrient")
parser.add_argument("--fr-only", action="store_true", help="Ne conserve que les versions (France) et (Fr)")
parser.add_argument("--eu-only", action="store_true", help="Ne liste que les jeux avec une version (France), (Fr), (Europe) ou (USA) avec Fr")
parser.add_argument("--all", action="store_true", help="Télécharge tous les fichiers sans filtrer par région")
parser.add_argument("--ra", action="store_true", help="Ne télécharge que les jeux compatibles RetroAchievements")
parser.add_argument("--extract", action="store_true", help="Télécharge le .zip dans /tmp, décompresse dans .work/, déplace dans le dossier final")
parser.add_argument("--chd", action="store_true", help="Télécharge le .zip dans /tmp, décompresse dans /tmp, convertit en .chd dans .work/, déplace dans le dossier final")
parser.add_argument("--max", type=int, default=3, help="Nombre maximum de téléchargements ou traitements simultanés (défaut : 3 pour standard, 1 pour --extract/--chd)")
parser.add_argument("--name", type=str, help="Ne télécharge que les jeux commençant par la chaîne spécifiée (ex: 'ab' pour les jeux commençant par 'ab', '0' pour les chiffres)")
parser.add_argument("--path", type=str, help="Chemin personnalisé pour les téléchargements (remplace le dossier courant ou ~/Downloads)")
parser.add_argument("--update", action="store_true", help="Reprend le téléchargement à partir de .check.txt")

# Vérifier si aucun argument n'est fourni
if len(sys.argv) == 1:
    current_dir = os.path.realpath(os.getcwd())
    home_dir = os.path.realpath(os.path.expanduser("~"))
    possible_dirs = [current_dir]
    try:
        download_dir = subprocess.check_output(["xdg-user-dir", "DOWNLOAD"], text=True).strip()
        possible_dirs.append(os.path.join(download_dir, "mydl"))
    except subprocess.CalledProcessError:
        possible_dirs.append(os.path.join(home_dir, "Downloads", "mydl"))

    check_file_path = None
    for dir_path in possible_dirs:
        potential_check = os.path.join(dir_path, ".check.txt")
        if os.path.exists(potential_check):
            check_file_path = potential_check
            download_dir = dir_path
            break

    if check_file_path:
        sys.argv.append("--update")
    else:
        parser.print_help()
        sys.exit(0)

args = parser.parse_args()

URL = args.url
FR_ONLY = args.fr_only
EU_ONLY = args.eu_only
ALL = args.all
RA_ONLY = args.ra
EXTRACT = args.extract
CHD = args.chd
MAX_WORKERS_DEFAULT = args.max
NAME_FILTER = args.name
CUSTOM_PATH = args.path
UPDATE = args.update

# Variable globale pour stocker l'ID de la console
CONSOLE_ID = None

# Vérifie les arguments
if UPDATE:
    if any([URL, FR_ONLY, EU_ONLY, ALL, RA_ONLY, EXTRACT, CHD, NAME_FILTER, CUSTOM_PATH]):
        print("Erreur : L'option --update ne peut pas être combinée avec d'autres options ou URL.")
        sys.exit(1)
else:
    if not URL:
        print("Erreur : Une URL Myrient est requise sauf avec --update.")
        sys.exit(1)
    if sum([FR_ONLY, EU_ONLY, ALL, RA_ONLY]) > 1:
        print("Erreur : Les options --fr-only, --eu-only, --all et --ra ne peuvent pas être utilisées ensemble.")
        sys.exit(1)
    if sum([EXTRACT, CHD]) > 1:
        print("Erreur : Les options --extract et --chd ne peuvent pas être utilisées ensemble.")
        sys.exit(1)
    if CHD and shutil.which("chdman") is None:
        print("Erreur : L'outil 'chdman' est requis pour l'option --chd mais n'est pas installé.")
        sys.exit(1)
    if MAX_WORKERS_DEFAULT < 1:
        print("Erreur : L'option --max doit être un entier positif (minimum 1).")
        sys.exit(1)
    if NAME_FILTER and not re.match(r'^[a-zA-Z0-9]+$', NAME_FILTER):
        print("Erreur : L'option --name doit contenir uniquement des lettres ou des chiffres (ex: 'ab', '0').")
        sys.exit(1)
    if CUSTOM_PATH:
        CUSTOM_PATH = os.path.expanduser(CUSTOM_PATH)
        if not os.path.isdir(CUSTOM_PATH):
            print(f"Erreur : Le chemin spécifié avec --path ('{CUSTOM_PATH}') n'est pas un dossier valide.")
            sys.exit(1)

# Menu interactif si aucune option de filtrage n’est spécifiée
if not UPDATE and not (FR_ONLY or EU_ONLY or ALL or RA_ONLY):
    print("Aucune option de filtrage spécifiée. Veuillez choisir une option :")
    print("1. --eu-only (par défaut)")
    print("2. --fr-only : Jeux uniquement en français")
    print("3. --all : Tous les fichiers sans filtrage par région")
    print("4. --ra : Jeux compatibles RetroAchievements")
    choice = input("Entrez votre choix (1, 2, 3, 4) ou appuyez sur Entrée pour --eu-only : ").strip()

    if choice == "" or choice == "1":
        EU_ONLY = True
    elif choice == "2":
        FR_ONLY = True
    elif choice == "3":
        ALL = True
    elif choice == "4":
        RA_ONLY = True
    else:
        print("Choix invalide. Utilisation de --eu-only par défaut.")
        EU_ONLY = True

# Détermine le dossier de téléchargement
if UPDATE:
    current_dir = os.path.realpath(os.getcwd())
    home_dir = os.path.realpath(os.path.expanduser("~"))
    possible_dirs = [current_dir]
    try:
        download_dir = subprocess.check_output(["xdg-user-dir", "DOWNLOAD"], text=True).strip()
        possible_dirs.append(os.path.join(download_dir, "mydl"))
    except subprocess.CalledProcessError:
        possible_dirs.append(os.path.join(home_dir, "Downloads", "mydl"))

    check_file_path = None
    for dir_path in possible_dirs:
        potential_check = os.path.join(dir_path, ".check.txt")
        if os.path.exists(potential_check):
            check_file_path = potential_check
            download_dir = dir_path
            break

    if not check_file_path:
        print("Erreur : Aucun fichier .check.txt trouvé dans le dossier courant ou ~/Downloads/mydl.")
        sys.exit(1)

    try:
        with open(check_file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        if not lines or not lines[0].startswith("Commande exécutée :"):
            print("Erreur : Format de .check.txt invalide ou commande manquante.")
            sys.exit(1)
        command = lines[0].split("Commande exécutée :")[1].strip()
        command_args = command.split()
        temp_args = parser.parse_args(command_args[1:])
        URL = temp_args.url
        FR_ONLY = temp_args.fr_only
        EU_ONLY = temp_args.eu_only
        ALL = temp_args.all
        RA_ONLY = temp_args.ra
        EXTRACT = temp_args.extract
        CHD = temp_args.chd
        MAX_WORKERS_DEFAULT = temp_args.max
        NAME_FILTER = temp_args.name
        CUSTOM_PATH = temp_args.path
        if CUSTOM_PATH:
            CUSTOM_PATH = os.path.expanduser(CUSTOM_PATH)
            download_dir = os.path.realpath(CUSTOM_PATH)
        if RA_ONLY:
            for line in lines:
                if line.startswith("Console ID pour RetroAchievements :"):
                    try:
                        CONSOLE_ID = int(line.split(":")[1].strip())
                    except ValueError:
                        print("Erreur : ID de console invalide dans .check.txt.")
                        sys.exit(1)
            if CONSOLE_ID is None:
                print("Erreur : Aucun ID de console trouvé dans .check.txt pour --ra.")
                sys.exit(1)
    except Exception as e:
        print(f"Erreur lors de la lecture de .check.txt : {e}")
        sys.exit(1)
else:
    if CUSTOM_PATH:
        download_dir = os.path.realpath(CUSTOM_PATH)
    else:
        current_dir = os.path.realpath(os.getcwd())
        home_dir = os.path.realpath(os.path.expanduser("~"))
        download_dir = current_dir

        if current_dir == home_dir:
            try:
                download_dir = subprocess.check_output(["xdg-user-dir", "DOWNLOAD"], text=True).strip()
            except subprocess.CalledProcessError:
                download_dir = os.path.join(home_dir, "Downloads")
            download_dir = os.path.join(download_dir, "mydl")
            os.makedirs(download_dir, exist_ok=True)
        else:
            download_dir = current_dir

# Créer le dossier .work
work_dir = os.path.join(download_dir, ".work")
os.makedirs(work_dir, exist_ok=True)

# Dossier pour les fichiers hash (pour --ra)
HASH_DIR = os.path.expanduser("~/.local/share/mydl/hash")
HASH_ZIP = "/usr/share/ublue-os/gablue/ra/hash.zip"

# Chemins temporaires et fichiers de check
RAW_OUTPUT = "/tmp/raw_download_links.txt"
CHECK_FILE_PATH = os.path.join(download_dir, ".check.txt")

# Fonction pour vérifier les fichiers dans le dossier
def initialize_progress_file(download_dir, selected_links=None):
    notinlist_dir = os.path.join(download_dir, ".notinlist")
    os.makedirs(notinlist_dir, exist_ok=True)

    selected_filenames = {urllib.parse.unquote(os.path.basename(link)) for link in selected_links} if selected_links else set()
    expected_filenames = set()
    if CHD:
        chd_filenames = {
            os.path.splitext(fn)[0] + ".chd" for fn in selected_filenames
            if fn.lower().endswith(('.zip', '.7z', '.rar'))
        }
        expected_filenames.update(chd_filenames)
    else:
        expected_filenames.update(selected_filenames)

    script_name = os.path.basename(sys.argv[0])
    excluded_files = {'.check.txt', script_name}

    existing_files = set()

    try:
        for f in os.listdir(download_dir):
            src_path = os.path.join(download_dir, f)
            if not os.path.isfile(src_path) or f in excluded_files:
                continue
            if f in expected_filenames and os.path.exists(src_path):
                existing_files.add(f)
            elif f not in excluded_files:
                dest_path = os.path.join(notinlist_dir, f)
                try:
                    shutil.move(src_path, dest_path)
                except Exception:
                    pass
        return existing_files
    except Exception:
        return existing_files

# Fonction pour écrire dans .check.txt
def write_check_file(check_file_path, selected_links, missing_games=None, console_id=None):
    try:
        with open(check_file_path, 'w', encoding='utf-8') as f:
            command = " ".join(sys.argv)
            f.write(f"Commande exécutée : {command}\n")
            if RA_ONLY and console_id is not None:
                f.write(f"Console ID pour RetroAchievements : {console_id}\n")
            f.write("\nFichiers à télécharger :\n")
            if selected_links:
                for link in sorted(selected_links):
                    filename = urllib.parse.unquote(os.path.basename(link))
                    f.write(f"- {filename}\n")
            else:
                f.write("Aucun fichier trouvé.\n")
            if missing_games:
                f.write("\nJeux RetroAchievements manquants (aucune ROM correspondante trouvée) :\n")
                for game in sorted(missing_games, key=lambda x: x['title']):
                    f.write(f"- {game['title']} (ID: {game['gameId']})\n")
                    if game['hashes']:
                        f.write("  Hashes associés :\n")
                        for hash_value in game['hashes']:
                            rom_info = next((rom for rom in game['compatible_roms'] if rom['hash'] == hash_value), None)
                            if rom_info and rom_info['filename']:
                                f.write(f"    - {rom_info['filename']} (Hash: {hash_value})\n")
                            else:
                                f.write(f"    - Nom inconnu (Hash: {hash_value})\n")
                    else:
                        f.write("  Aucun hash disponible.\n")
    except Exception as e:
        print(f"Erreur lors de l'écriture dans {check_file_path}: {e}")

# Fonction pour vérifier et extraire hash.zip si nécessaire
def ensure_hash_directory():
    if os.path.exists(HASH_DIR):
        return True

    if not os.path.exists(HASH_ZIP):
        return False

    try:
        os.makedirs(os.path.dirname(HASH_DIR), exist_ok=True)
        with zipfile.ZipFile(HASH_ZIP, 'r') as zip_ref:
            zip_ref.extractall(os.path.dirname(HASH_DIR))
        return os.path.exists(HASH_DIR)
    except Exception:
        return False

# Fonction pour lire ou sauvegarder les identifiants RetroAchievements
def get_ra_credentials():
    config = configparser.ConfigParser()
    username = None
    api_key = None

    if os.path.exists(CONFIG_FILE):
        try:
            config.read(CONFIG_FILE)
            if 'RetroAchievements' in config:
                username = config['RetroAchievements'].get('username', '').strip()
                api_key = config['RetroAchievements'].get('api_key', '').strip()
                if not username or not api_key:
                    username = None
                    api_key = None
        except Exception:
            pass

    if not username or not api_key:
        username = input("Entrez votre nom d'utilisateur RetroAchievements : ").strip()
        api_key = input("Entrez votre clé API RetroAchievements : ").strip()

        try:
            os.makedirs(CONFIG_DIR, exist_ok=True)
            config['RetroAchievements'] = {
                'username': username,
                'api_key': api_key
            }
            with open(CONFIG_FILE, 'w', encoding='utf-8') as configfile:
                config.write(configfile)
        except Exception as e:
            print(f"Erreur lors de la sauvegarde des identifiants dans {CONFIG_FILE}: {e}")

    return username, api_key

# Fonction pour appeler l'API RetroAchievements
def call_ra_api(endpoint, params, username, api_key):
    params["z"] = username
    params["y"] = api_key
    try:
        response = requests.get(RA_API_BASE_URL + endpoint, params=params, timeout=10)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.HTTPError as e:
        if response.status_code == 401:
            try:
                if os.path.exists(CONFIG_FILE):
                    os.remove(CONFIG_FILE)
            except Exception:
                pass
            raise AuthenticationError("Authentification échouée. Veuillez fournir de nouveaux identifiants.")
        return None
    except Exception:
        return None

# Fonction pour sélectionner une console RetroAchievements
def select_ra_console(username, api_key, console_id=None):
    consoles = call_ra_api("API_GetConsoleIDs.php", {}, username, api_key)
    if not consoles:
        return None

    if console_id is not None:
        console = next((c for c in consoles if str(c["ID"]) == str(console_id)), None)
        return console

    print("\nConsoles disponibles avec RetroAchievements :")
    for console in sorted(consoles, key=lambda x: x["Name"]):
        print(f"  ID: {console['ID']}, Nom: {console['Name']}")

    while True:
        console_id = input("\nEntrez l'ID de la console correspondant à votre URL Myrient (ou 'q' pour quitter) : ").strip().lower()
        if console_id == 'q':
            return None
        console = next((c for c in consoles if str(c["ID"]) == console_id), None)
        if console:
            return console
        print("ID de console invalide. Veuillez réessayer.")

# Fonction pour récupérer les jeux RetroAchievements
def get_ra_games():
    global CONSOLE_ID
    if not RA_ONLY:
        return None

    retry = True
    while retry:
        retry = False
        try:
            username, api_key = get_ra_credentials()
            console = select_ra_console(username, api_key, CONSOLE_ID)
            if not console:
                return None

            CONSOLE_ID = console["ID"]

            params = {"i": console["ID"], "f": 3, "h": 1}
            games = call_ra_api("API_GetGameList.php", params, username, api_key)
            if not games:
                return None

            game_list = []
            all_hashes = set()
            for game in games:
                title = game["Title"]
                if any(tag in title for tag in ["[Subset", "~Hack~", "~Homebrew~", "~Demo~", "~Prototype~", "~Unlicensed~"]):
                    continue
                hashes = game.get("Hashes", []) if isinstance(game.get("Hashes"), list) else []
                all_hashes.update(h.lower() for h in hashes)
                game_list.append({
                    "title": title,
                    "console": console["Name"],
                    "gameId": game["ID"],
                    "hashes": hashes,
                    "compatible_roms": []
                })

            if not ensure_hash_directory():
                for game in game_list:
                    for hash_value in game["hashes"]:
                        game["compatible_roms"].append({
                            "hash": hash_value,
                            "filename": None,
                            "game_name": None
                        })
                return game_list

            hash_files = []
            for root, _, files in os.walk(HASH_DIR):
                for file in files:
                    if file.lower().endswith('.txt'):
                        hash_files.append(os.path.join(root, file))

            if not hash_files:
                for game in game_list:
                    for hash_value in game["hashes"]:
                        game["compatible_roms"].append({
                            "hash": hash_value,
                            "filename": None,
                            "game_name": None
                        })
                return game_list

            hash_to_filenames = {}
            for hash_file in hash_files:
                try:
                    with open(hash_file, 'r', encoding='utf-8') as f:
                        for line in f:
                            line = line.strip()
                            if not line:
                                continue
                            parts = line.split('\t')
                            if len(parts) < 2:
                                continue
                            md5 = parts[0].lower()
                            game_name = parts[1]
                            if not re.match(r'^[0-9a-f]{32}$', md5):
                                continue
                            if md5 in all_hashes:
                                if md5 not in hash_to_filenames:
                                    hash_to_filenames[md5] = []
                                if not any(info["game_name"] == game_name for info in hash_to_filenames[md5]):
                                    hash_to_filenames[md5].append({"game_name": game_name, "filename": game_name})
                except Exception:
                    pass

            for game in game_list:
                for hash_value in game["hashes"]:
                    hash_lower = hash_value.lower()
                    if hash_lower in hash_to_filenames:
                        for rom_info in hash_to_filenames[hash_lower]:
                            if not any(r["hash"] == hash_value and r["game_name"] == rom_info["game_name"] for r in game["compatible_roms"]):
                                game["compatible_roms"].append({
                                    "hash": hash_value,
                                    "filename": rom_info["filename"],
                                    "game_name": rom_info["game_name"]
                                })
                    else:
                        if not any(r["hash"] == hash_value for r in game["compatible_roms"]):
                            game["compatible_roms"].append({
                                "hash": hash_value,
                                "filename": None,
                                "game_name": None
                            })

            return game_list

        except AuthenticationError:
            retry = True
        except Exception:
            return None

    return None

# Fonction pour nettoyer un nom de fichier
def clean_filename(filename, region=None):
    name = re.sub(r'\.[a-zA-Z0-9]+$', '', filename)
    if region:
        name = re.sub(r'\s*\(' + re.escape(region) + r'\)\s*', '', name, flags=re.IGNORECASE)
    name = re.sub(r'\s+', ' ', name).strip().lower()
    return name

# Fonction pour extraire la révision
def extract_revision(filename):
    match = re.search(r'\(Rev(?:ision)?\s*(\d+)\)', filename, re.IGNORECASE)
    return int(match.group(1)) if match else 0

# Fonction pour attribuer une priorité à une ROM
def get_rom_priority(filename, is_japan_specific=False, mode=None):
    filename_lower = filename.lower()
    parenthetical_parts = re.findall(r'\((.*?)\)', filename_lower)
    has_french = any(
        'fr' in part.lower().split(',') or part.strip().lower() == 'fr'
        for part in parenthetical_parts
    )
    is_japanese = '(japan)' in filename_lower or '(j)' in filename_lower or '(ja)' in filename_lower
    has_europe = any('europe' in part.lower() for part in parenthetical_parts)

    if mode == "ra":
        if is_japan_specific and is_japanese:
            return 0
        if '(usa)' in filename_lower and has_french:
            return 1
        if '(canada)' in filename_lower and has_french:
            return 2
        if '(france)' in filename_lower or has_french:
            return 3
        if has_europe and has_french:
            return 4
        if '(usa)' in filename_lower:
            return 5
        if has_europe:
            return 6
        if is_japanese:
            return 7
        return 8
    elif mode == "eu_only":
        if '(usa)' in filename_lower and has_french:
            return 1
        if '(canada)' in filename_lower and has_french:
            return 2
        if '(france)' in filename_lower or has_french:
            return 3
        if has_europe and has_french:
            return 4
        if '(usa)' in filename_lower:
            return 5
        if has_europe:
            return 6
        if is_japanese:
            return 7
        return 8
    else:
        if is_japan_specific and is_japanese:
            return 0
        if '(usa)' in filename_lower and has_french:
            return 1
        if '(canada)' in filename_lower and has_french:
            return 2
        if '(france)' in filename_lower or has_french:
            return 3
        if has_europe and has_french:
            return 4
        if '(usa)' in filename_lower:
            return 5
        if has_europe:
            return 6
        if is_japanese:
            return 7
        return 8

# Fonction pour filtrer une seule version par jeu RetroAchievements
def filter_single_version(game_list):
    filtered_list = []
    for game in game_list:
        filtered_game = game.copy()
        compatible_roms = filtered_game["compatible_roms"]
        if not compatible_roms:
            filtered_list.append(filtered_game)
            continue

        is_japan_specific = "Japan" in game["title"] or game["title"].startswith("Pocket Monsters")

        hash_to_roms = {}
        for rom in compatible_roms:
            hash_value = rom["hash"]
            if hash_value not in hash_to_roms:
                hash_to_roms[hash_value] = []
            hash_to_roms[hash_value].append(rom)

        filtered_hash_to_roms = {}
        for hash_value, roms in hash_to_roms.items():
            non_beta_roms = [rom for rom in roms if rom["filename"] and "(beta)" not in rom["filename"].lower()]
            if non_beta_roms:
                best_rom = max(
                    non_beta_roms,
                    key=lambda rom: (
                        extract_revision(rom["filename"]),
                        -get_rom_priority(rom["filename"], is_japan_specific, mode="ra")
                    )
                )
                filtered_hash_to_roms[hash_value] = [best_rom]
            else:
                best_rom = max(
                    roms,
                    key=lambda rom: (
                        extract_revision(rom["filename"]) if rom["filename"] else -1,
                        -get_rom_priority(rom["filename"], is_japan_specific, mode="ra") if rom["filename"] else 0
                    )
                )
                filtered_hash_to_roms[hash_value] = [best_rom]

        is_multi_disc = any(
            "(disc" in rom["filename"].lower() for roms in filtered_hash_to_roms.values() for rom in roms if rom["filename"]
        )

        if is_multi_disc:
            region_to_roms = {}
            for hash_value, roms in filtered_hash_to_roms.items():
                for rom in roms:
                    if not rom["filename"]:
                        continue
                    filename_lower = rom["filename"].lower()
                    region = "unknown"
                    if "(usa)" in filename_lower:
                        region = "usa"
                    elif "(canada)" in filename_lower:
                        region = "canada"
                    elif "(france)" in filename_lower or "(fr)" in filename_lower:
                        region = "france"
                    elif "(europe)" in filename_lower:
                        region = "europe"
                    elif "(japan)" in filename_lower or "(j)" in filename_lower or "(ja)" in filename_lower:
                        region = "japan"
                    if region not in region_to_roms:
                        region_to_roms[region] = []
                    region_to_roms[region].append(rom)

            if not region_to_roms:
                filtered_game["compatible_roms"] = [rom for roms in filtered_hash_to_roms.values() for rom in roms]
            else:
                best_region = None
                best_priority = float('inf')
                best_revision = -float('inf')
                for region, roms in region_to_roms.items():
                    valid_roms = [rom for rom in roms if rom["filename"]]
                    if not valid_roms:
                        continue
                    best_rom_for_region = max(
                        valid_roms,
                        key=lambda rom: (
                            extract_revision(rom["filename"]),
                            -get_rom_priority(rom["filename"], is_japan_specific, mode="ra")
                        )
                    )
                    priority = get_rom_priority(best_rom_for_region["filename"], is_japan_specific, mode="ra")
                    revision = extract_revision(best_rom_for_region["filename"])
                    if (priority < best_priority) or (priority == best_priority and revision > best_revision):
                        best_region = region
                        best_priority = priority
                        best_revision = revision
                if best_region:
                    filtered_game["compatible_roms"] = region_to_roms[best_region]
                else:
                    filtered_game["compatible_roms"] = [rom for roms in filtered_hash_to_roms.values() for rom in roms]
        else:
            best_hash = None
            best_priority = float('inf')
            best_revision = -float('inf')
            for hash_value, roms in filtered_hash_to_roms.items():
                valid_roms = [rom for rom in roms if rom["filename"]]
                if not valid_roms:
                    continue
                best_rom_for_hash = max(
                    valid_roms,
                    key=lambda rom: (
                        extract_revision(rom["filename"]),
                        -get_rom_priority(rom["filename"], is_japan_specific, mode="ra")
                    )
                )
                priority = get_rom_priority(best_rom_for_hash["filename"], is_japan_specific, mode="ra")
                revision = extract_revision(best_rom_for_hash["filename"])
                if (priority < best_priority) or (priority == best_priority and revision > best_revision):
                    best_hash = hash_value
                    best_priority = priority
                    best_revision = revision
            if best_hash:
                filtered_game["compatible_roms"] = filtered_hash_to_roms[best_hash]
            else:
                filtered_game["compatible_roms"] = [rom for roms in filtered_hash_to_roms.values() for rom in roms]

        filtered_list.append(filtered_game)
    return filtered_list

# Récupère les liens à traiter
links = []
selected_links = []
missing_games = []

if UPDATE:
    try:
        with open(CHECK_FILE_PATH, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        start_files = False
        for line in lines:
            line = line.strip()
            if line == "Fichiers à télécharger :":
                start_files = True
                continue
            if start_files and line.startswith("- "):
                filename = line[2:].strip()
                link = f"{URL}{urllib.parse.quote(filename)}"
                selected_links.append(link)
        if not selected_links:
            print("Aucun fichier à télécharger trouvé dans .check.txt.")
            sys.exit(1)

        filtered_links = []
        for link in selected_links:
            filename = urllib.parse.unquote(os.path.basename(link))
            if NAME_FILTER:
                cleaned_name = re.sub(r'\s*\([^\)]*\)', '', filename).lower()
                cleaned_name = re.sub(r'\.[a-zA-Z0-9]+$', '', cleaned_name)
                if NAME_FILTER.lower() == '0':
                    if re.match(r'^\d', cleaned_name, re.IGNORECASE):
                        filtered_links.append(link)
                else:
                    if cleaned_name.startswith(NAME_FILTER.lower()):
                        filtered_links.append(link)
            else:
                filtered_links.append(link)

        if not filtered_links:
            print(f"Aucun fichier correspondant au filtre {'--name ' + NAME_FILTER if NAME_FILTER else ''} dans .check.txt.")
            sys.exit(1)

        existing_files = initialize_progress_file(download_dir, selected_links)

        links = []
        for link in filtered_links:
            filename = urllib.parse.unquote(os.path.basename(link))
            if CHD:
                chd_filename = os.path.splitext(filename)[0] + ".chd"
                if chd_filename not in existing_files:
                    links.append(link)
            else:
                if filename not in existing_files:
                    links.append(link)

        if not links:
            print("Tous les fichiers sont déjà téléchargés ou traités.")
            sys.exit(0)
    except Exception as e:
        print(f"Erreur lors de la lecture des liens dans {CHECK_FILE_PATH} : {e}")
        sys.exit(1)
else:
    response = requests.get(URL)
    links = re.findall(r'href="([^"]+\.(?:bin|cue|iso|zip|7z|rar|z64))"', response.text)
    if not links:
        print("Aucun lien de fichier trouvé.")
        sys.exit(1)

    with open(RAW_OUTPUT, 'w') as f:
        for link in links:
            f.write(f"{URL}{link}\n")

    def get_server_file_size(url):
        try:
            response = requests.head(url, allow_redirects=True, timeout=10)
            if response.status_code == 200:
                return int(response.headers.get("content-length", 0))
            return None
        except requests.RequestException:
            return None

    def contains_term(filename, term):
        pattern = r'\b' + re.escape(term) + r'\b'
        return bool(re.search(pattern, filename, re.IGNORECASE))

    def get_game_name(filename):
        name = re.sub(r'\s*\([^\)]*\)', '', filename)
        name = re.sub(r'\s*-\s*Disc\s*[0-9]+', '', name)
        name = re.sub(r'\.[a-zA-Z0-9]+$', '', name)
        name = name.lower()
        name = re.sub(r'[^a-z0-9]+', '-', name)
        return name.strip('-')

    def get_disc_num(filename):
        match = re.search(r'Disc\s*([0-9]+)', filename, re.IGNORECASE)
        if match:
            return match.group(1)
        return "0"

    game_versions = {}
    game_regions = {}

    if RA_ONLY:
        ra_games = get_ra_games()
        if not ra_games:
            print("Aucun jeu RetroAchievements trouvé. Arrêt du script.")
            sys.exit(1)

        ra_games = filter_single_version(ra_games)

        ra_filenames = {}
        for game in ra_games:
            is_japan_specific = "Japan" in game["title"] or game["title"].startswith("Pocket Monsters")
            region = "Japan" if is_japan_specific else None
            for rom in game["compatible_roms"]:
                if rom["filename"]:
                    cleaned_name = clean_filename(rom["filename"], region=region)
                    key = (game["gameId"], cleaned_name)
                    if key not in ra_filenames:
                        ra_filenames[key] = []
                    ra_filenames[key].append((game, rom["filename"]))

        with open(RAW_OUTPUT, 'r') as f:
            for link in f:
                link = link.strip()
                filename = urllib.parse.unquote(os.path.basename(link))
                cleaned_filename = clean_filename(filename)
                cleaned_filename_japan = clean_filename(filename, region="Japan")
                cleaned_filename_usa = clean_filename(filename, region="USA")
                cleaned_filename_europe = clean_filename(filename, region="Europe")

                for cleaned_name in [cleaned_filename, cleaned_filename_japan, cleaned_filename_usa, cleaned_filename_europe]:
                    for (game_id, rom_cleaned_name), game_roms in ra_filenames.items():
                        if rom_cleaned_name == cleaned_name:
                            for game, _ in game_roms:
                                key = f"{get_game_name(filename)}_disc_{get_disc_num(filename)}_{game['gameId']}"
                                is_japan_specific = "Japan" in game["title"] or game["title"].startswith("Pocket Monsters")
                                priority = get_rom_priority(filename, is_japan_specific, mode="ra")
                                if key not in game_versions or priority < game_versions[key][1]:
                                    game_versions[key] = (link, priority, filename)
                                if game["title"] not in game_regions:
                                    game_regions[game["title"]] = set()
                                game_regions[game["title"]].add("RA")

        found_titles = set()
        for key, (link, _, _) in game_versions.items():
            game_id = key.split('_')[-1]
            for game in ra_games:
                if str(game["gameId"]) == game_id:
                    found_titles.add(game["title"])
                    break
        missing_games = [game for game in ra_games if game["title"] not in found_titles]

        selected_links = [version[0] for version in game_versions.values()]
        if not selected_links:
            print("Aucun jeu trouvé correspondant au filtre RA après filtrage.")
            sys.exit(1)
    else:
        with open(RAW_OUTPUT, 'r') as f:
            for link in f:
                link = link.strip()
                filename = urllib.parse.unquote(os.path.basename(link))

                game_name = get_game_name(filename)
                disc_num = get_disc_num(filename)

                if contains_term(filename, "Demo") or contains_term(filename, "Beta"):
                    continue

                key = f"{game_name}_disc_{disc_num}"

                if ALL:
                    priority = 0
                    region = "All"
                else:
                    priority = None
                    region = None
                    parenthetical_parts = [part for part in re.findall(r'\((.*?)\)', filename, re.IGNORECASE)]
                    has_french = any(
                        'fr' in part.lower().split(',') or part.strip().lower() == 'fr'
                        for part in parenthetical_parts
                    )
                    has_europe = any("europe" in part.lower() for part in parenthetical_parts)
                    if contains_term(filename, "USA") and has_french:
                        priority = 1
                        region = "USA_Fr"
                    elif contains_term(filename, "Canada") and has_french:
                        priority = 2
                        region = "Canada_Fr"
                    elif contains_term(filename, "France") or has_french:
                        priority = 3
                        region = "France"
                    elif has_europe and has_french:
                        priority = 4
                        region = "Europe_Fr"
                    elif contains_term(filename, "USA"):
                        priority = 5
                        region = "USA"
                    elif has_europe:
                        priority = 6
                        region = "Europe"
                    else:
                        continue

                    if game_name not in game_regions:
                        game_regions[game_name] = set()
                    game_regions[game_name].add(region)
                    if key not in game_versions or priority < game_versions[key][1]:
                        game_versions[key] = (link, get_rom_priority(filename, mode="eu_only"), filename)

        selected_links = []
        for key, (link, _, filename) in game_versions.items():
            game_name = key.split('_disc_')[0]
            regions = game_regions[game_name]
            if EU_ONLY and not any(r in {"USA_Fr", "Canada_Fr", "France", "Europe_Fr", "USA", "Europe"} for r in regions):
                continue
            if FR_ONLY and not any(r in {"France", "USA_Fr", "Europe_Fr"} for r in regions):
                continue
            selected_links.append(link)

        if not selected_links:
            print(f"Aucun jeu trouvé correspondant au filtre de région après filtrage.")
            sys.exit(1)

    write_check_file(CHECK_FILE_PATH, selected_links, missing_games if RA_ONLY else None, CONSOLE_ID if RA_ONLY else None)

    existing_files = initialize_progress_file(download_dir, selected_links)

    links = []
    for link in selected_links:
        filename = urllib.parse.unquote(os.path.basename(link))
        if NAME_FILTER:
            cleaned_name = re.sub(r'\s*\([^\)]*\)', '', filename).lower()
            cleaned_name = re.sub(r'\.[a-zA-Z0-9]+$', '', cleaned_name)
            if NAME_FILTER.lower() == '0':
                if not re.match(r'^\d', cleaned_name, re.IGNORECASE):
                    continue
            elif not cleaned_name.startswith(NAME_FILTER.lower()):
                continue
        if CHD:
            chd_filename = os.path.splitext(filename)[0] + ".chd"
            if chd_filename not in existing_files:
                links.append(link)
        else:
            if filename not in existing_files:
                links.append(link)

    if not links:
        print("Tous les fichiers sont déjà téléchargés ou traités.")
        if os.path.exists(RAW_OUTPUT):
            os.remove(RAW_OUTPUT)
        sys.exit(0)

# Fonction pour tronquer les noms
def truncate_filename(filename, max_length=15):
    if len(filename) <= max_length:
        return filename
    return filename[:max_length-3] + "..."

# Fonction pour télécharger un fichier avec reprise et barre de progression
def download_file_to_tmp(url, tmp_path, position=0):
    if shutdown_event.is_set():
        return False, url

    filename = urllib.parse.unquote(os.path.basename(url))
    display_name = truncate_filename(filename)

    resume_byte_pos = 0
    if os.path.exists(tmp_path):
        resume_byte_pos = os.path.getsize(tmp_path)

    headers = {"Range": f"bytes={resume_byte_pos}-"} if resume_byte_pos else {}
    try:
        response = requests.get(url, headers=headers, stream=True, timeout=30)
    except requests.RequestException as e:
        print(f"Échec du téléchargement de {filename} : {e}")
        return False, url

    if response.status_code == 416:
        server_size = get_server_file_size(url)
        if server_size and resume_byte_pos >= server_size:
            return True, url
        print(f"Échec du téléchargement de {filename} : Requête de reprise invalide")
        return False, url

    if response.status_code not in (200, 206):
        print(f"Échec du téléchargement de {filename} : Statut {response.status_code}")
        return False, url

    total_size = int(response.headers.get("content-length", 0)) + resume_byte_pos
    block_size = 1024

    with tqdm(total=total_size, initial=resume_byte_pos, unit="B", unit_scale=True, desc=display_name, position=position, leave=True, mininterval=0.2, bar_format="{l_bar}{bar}| {n_fmt}/{total_fmt}") as progress_bar:
        with open(tmp_path, "ab" if resume_byte_pos else "wb") as f:
            try:
                for chunk in response.iter_content(chunk_size=block_size):
                    if shutdown_event.is_set():
                        return False, url
                    if chunk:
                        f.write(chunk)
                        progress_bar.update(len(chunk))
            except requests.RequestException as e:
                print(f"Échec du téléchargement de {filename} : {e}")
                return False, url

    server_size = get_server_file_size(url)
    local_size = os.path.getsize(tmp_path)
    if server_size and local_size == server_size:
        return True, url
    else:
        print(f"Téléchargement de {filename} incomplet (local: {local_size}, serveur: {server_size})")
        return False, url

# Fonction pour décompresser un .zip
def extract_zip(zip_path, dest_dir):
    try:
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(dest_dir)
        return True
    except Exception as e:
        print(f"Échec de la décompression de {os.path.basename(zip_path)} : {e}")
        return False

# Fonction pour convertir en .chd avec chdman
def convert_to_chd(cue_or_iso_path, work_dir, existing_files):
    output_chd = os.path.join(work_dir, os.path.splitext(os.path.basename(cue_or_iso_path))[0] + ".chd")
    chd_filename = os.path.basename(output_chd)

    if os.path.exists(output_chd) and chd_filename not in existing_files:
        os.remove(output_chd)

    command = ["chdman"]
    if cue_or_iso_path.lower().endswith('.cue'):
        command.append("createcd")
    elif cue_or_iso_path.lower().endswith('.iso'):
        command.append("createdvd")
    else:
        print(f"Format non supporté pour {os.path.basename(cue_or_iso_path)} : doit être .cue ou .iso")
        return False, None

    command.extend(["-i", cue_or_iso_path, "-o", output_chd])

    try:
        subprocess.run(command, capture_output=True, text=True, check=True)
        return True, output_chd
    except subprocess.CalledProcessError as e:
        print(f"Échec de la conversion de {os.path.basename(cue_or_iso_path)} : {e.stderr}")
        return False, None
    except Exception as e:
        print(f"Erreur lors de la conversion de {os.path.basename(cue_or_iso_path)} : {e}")
        return False, None

# Fonction pour déplacer les fichiers du dossier .work vers le dossier final
def move_to_final(work_dir, download_dir, filenames):
    for filename in filenames:
        src_path = os.path.join(work_dir, filename)
        dest_path = os.path.join(download_dir, filename)
        try:
            if os.path.exists(dest_path):
                os.remove(dest_path)
            shutil.move(src_path, dest_path)
        except Exception as e:
            print(f"Erreur lors du déplacement de {filename} : {e}")
            return False
    return True

# Fonction principale pour traiter un fichier avec --extract
def process_extract(url, download_dir, work_dir, existing_files, position=0):
    filename = urllib.parse.unquote(os.path.basename(url))
    if filename in existing_files:
        return True, url

    tmp_zip = os.path.join("/tmp", f"myrientdl_{os.path.basename(url)}")
    try:
        success, _ = download_file_to_tmp(url, tmp_zip, position)
        if not success or shutdown_event.is_set():
            if os.path.exists(tmp_zip):
                os.remove(tmp_zip)
            return False, url

        if not extract_zip(tmp_zip, work_dir):
            os.remove(tmp_zip)
            return False, url

        extracted_files = [f for f in os.listdir(work_dir) if os.path.isfile(os.path.join(work_dir, f))]
        if not extracted_files:
            print(f"Aucun fichier extrait pour {filename}")
            os.remove(tmp_zip)
            return False, url

        if not move_to_final(work_dir, download_dir, extracted_files):
            os.remove(tmp_zip)
            return False, url

        return True, url
    finally:
        if os.path.exists(tmp_zip):
            os.remove(tmp_zip)

# Fonction principale pour traiter un fichier avec --chd
def process_chd(url, download_dir, work_dir, existing_files, position=0):
    filename = urllib.parse.unquote(os.path.basename(url))
    chd_filename = os.path.splitext(filename)[0] + ".chd"
    if chd_filename in existing_files:
        return True, url

    tmp_zip = os.path.join("/tmp", f"myrientdl_{os.path.basename(url)}")
    with tempfile.TemporaryDirectory(prefix="myrientdl_", dir="/tmp") as tmp_extract_dir:
        try:
            success, _ = download_file_to_tmp(url, tmp_zip, position)
            if not success or shutdown_event.is_set():
                return False, url

            if not extract_zip(tmp_zip, tmp_extract_dir):
                return False, url

            if os.path.exists(tmp_zip):
                os.remove(tmp_zip)

            chd_created = False
            chd_files = []
            for root, _, files in os.walk(tmp_extract_dir):
                for file in files:
                    if file.lower().endswith(('.cue', '.iso')):
                        cue_or_iso_path = os.path.join(root, file)
                        success, output_chd = convert_to_chd(cue_or_iso_path, work_dir, existing_files)
                        if success and output_chd:
                            chd_filename = os.path.basename(output_chd)
                            chd_files.append(chd_filename)
                            chd_created = True
                        if not success or shutdown_event.is_set():
                            return False, url

            if not chd_created:
                print(f"Aucun fichier .cue ou .iso trouvé dans {filename}")
                return False, url

            if not move_to_final(work_dir, download_dir, chd_files):
                return False, url

            return True, url
        finally:
            if os.path.exists(tmp_zip):
                os.remove(tmp_zip)

# Fonction pour télécharger un fichier directement
def download_file(url, download_dir, work_dir, existing_files, position=0):
    if shutdown_event.is_set():
        return False, url

    filename = urllib.parse.unquote(os.path.basename(url))
    work_path = os.path.join(work_dir, filename)
    dest_path = os.path.join(download_dir, filename)
    display_name = truncate_filename(filename)

    if filename in existing_files:
        return True, url

    resume_byte_pos = 0
    if os.path.exists(work_path):
        resume_byte_pos = os.path.getsize(work_path)
    elif os.path.exists(dest_path):
        server_size = get_server_file_size(url)
        local_size = os.path.getsize(dest_path)
        if server_size and local_size == server_size:
            return True, url

    headers = {"Range": f"bytes={resume_byte_pos}-"} if resume_byte_pos else {}
    try:
        response = requests.get(url, headers=headers, stream=True, timeout=30)
    except requests.RequestException as e:
        print(f"Échec du téléchargement de {filename} : {e}")
        return False, url

    if response.status_code == 416:
        server_size = get_server_file_size(url)
        if server_size and resume_byte_pos >= server_size:
            if move_to_final(work_dir, download_dir, [filename]):
                return True, url
        print(f"Échec du téléchargement de {filename} : Requête de reprise invalide")
        return False, url

    if response.status_code not in (200, 206):
        print(f"Échec du téléchargement de {filename} : Statut {response.status_code}")
        return False, url

    total_size = int(response.headers.get("content-length", 0)) + resume_byte_pos
    block_size = 1024

    with tqdm(total=total_size, initial=resume_byte_pos, unit="B", unit_scale=True, desc=display_name, position=position, leave=True, mininterval=0.2, bar_format="{l_bar}{bar}| {n_fmt}/{total_fmt}") as progress_bar:
        with open(work_path, "ab" if resume_byte_pos else "wb") as f:
            try:
                for chunk in response.iter_content(chunk_size=block_size):
                    if shutdown_event.is_set():
                        return False, url
                    if chunk:
                        f.write(chunk)
                        progress_bar.update(len(chunk))
            except requests.RequestException as e:
                print(f"Échec du téléchargement de {filename} : {e}")
                return False, url

    server_size = get_server_file_size(url)
    local_size = os.path.getsize(work_path)
    if server_size and local_size == server_size:
        if move_to_final(work_dir, download_dir, [filename]):
            return True, url
        return False, url
    else:
        print(f"Téléchargement de {filename} incomplet (local: {local_size}, serveur: {server_size})")
        return False, url

# Exécution des téléchargements ou traitements
MAX_WORKERS = MAX_WORKERS_DEFAULT
if (EXTRACT or CHD) and args.max == 3:
    MAX_WORKERS = 1

try:
    if EXTRACT:
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            future_to_url = {executor.submit(process_extract, link, download_dir, work_dir, existing_files, i % MAX_WORKERS): link for i, link in enumerate(sorted(links))}
            for future in as_completed(future_to_url):
                if shutdown_event.is_set():
                    executor._threads.clear()
                    executor.shutdown(wait=False)
                    break
                try:
                    success, url = future.result()
                    if not success:
                        print(f"Erreur lors du traitement de {urllib.parse.unquote(os.path.basename(url))}")
                except Exception as e:
                    print(f"Erreur dans le thread pour {urllib.parse.unquote(os.path.basename(future_to_url[future]))} : {e}")
    elif CHD:
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            future_to_url = {executor.submit(process_chd, link, download_dir, work_dir, existing_files, i % MAX_WORKERS): link for i, link in enumerate(sorted(links))}
            for future in as_completed(future_to_url):
                if shutdown_event.is_set():
                    executor._threads.clear()
                    executor.shutdown(wait=False)
                    break
                try:
                    success, url = future.result()
                    if not success:
                        print(f"Erreur lors du traitement de {urllib.parse.unquote(os.path.basename(url))}")
                except Exception as e:
                    print(f"Erreur dans le thread pour {urllib.parse.unquote(os.path.basename(future_to_url[future]))} : {e}")
    else:
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            future_to_url = {executor.submit(download_file, link, download_dir, work_dir, existing_files, i % MAX_WORKERS): link for i, link in enumerate(sorted(links))}
            for future in as_completed(future_to_url):
                if shutdown_event.is_set():
                    executor._threads.clear()
                    executor.shutdown(wait=False)
                    break
                try:
                    success, url = future.result()
                    if not success:
                        print(f"Erreur lors du téléchargement de {urllib.parse.unquote(os.path.basename(url))}")
                except Exception as e:
                    print(f"Erreur dans le thread pour {urllib.parse.unquote(os.path.basename(future_to_url[future]))} : {e}")
except KeyboardInterrupt:
    shutdown_event.set()
    print("\nTraitement interrompu par l'utilisateur.")
    sys.exit(1)
except Exception as e:
    print(f"Erreur inattendue : {e}")
    sys.exit(1)

# Nettoyage du dossier .work
try:
    if os.path.exists(work_dir):
        shutil.rmtree(work_dir)
except Exception as e:
    print(f"Erreur lors de la suppression de {work_dir} : {e}")

# Supprime les fichiers temporaires
if os.path.exists(RAW_OUTPUT):
    os.remove(RAW_OUTPUT)

if not shutdown_event.is_set():
    print("Tous les traitements terminés.")
