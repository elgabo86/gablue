#!/usr/bin/bash

# Arrêter le script à la moindre erreur (sauf pour Ctrl+C)
set -e

user=$(whoami)
dossieruser="~/Windows/UserData/$user"
dxvkversion="dxvk-gplasync-v2.7.1-1"
vkd3dversion="vkd3d-proton-3.0"
nvapiversion="dxvk-nvapi-v0.9.0"
latencyflexversion="latencyflex-v0.1.1-2-3bc9636"
soda_version="soda-9.0-1"
soda_url="https://github.com/bottlesdevs/wine/releases/download/$soda_version/$soda_version-x86_64.tar.xz"

# Dossier temporaire pour sauvegarder les anciennes versions
temp_dir=~/.var/app/com.usebottles.bottles/data/bottles/temp_updates
mkdir -p "$temp_dir"

# Fichier drapeau pour contrôler la boucle de surveillance
flag_file="/tmp/kdialog_monitor_flag_$$"
touch "$flag_file"

# Vérifier l'argument --rebuild
force_rebuild=false
if [ "$1" = "--rebuild" ]; then
    force_rebuild=true
    echo "Mode forcé --rebuild activé"
fi

# Choix entre gwine, gwine-proton, gwine-proton-wow64 et soda avec kdialog
runner_choice=$(kdialog --title "Choix de wine" --radiolist "Sélectionnez la version de wine à utiliser :" \
    "gwine-proton" "Gwine-Proton (dernière version)" on \
    "gwine" "Gwine (dernière version)" off \
    "gwine-proton-wow64" "Gwine-Proton-WoW64 (dernière version)" off \
    "soda" "Soda (ancienne version)" off)

if [ $? -ne 0 ] || [ -z "$runner_choice" ]; then
    kdialog --msgbox "Aucun choix effectué, arrêt du script."
    exit 1
fi

# Récupérer la dernière version de gwine, gwine-proton ou gwine-proton-wow64 si sélectionné
if [ "$runner_choice" = "gwine" ] || [ "$runner_choice" = "gwine-proton" ] || [ "$runner_choice" = "gwine-proton-wow64" ]; then
    API_URL="https://api.github.com/repos/elgabo86/gwine/releases"
    # Use exact match for runner_choice to avoid overlap between gwine-proton and gwine-proton-wow64
    # Sort by published_at to get the most recent release by date
    if [ "$runner_choice" = "gwine-proton" ]; then
        wineversion=$(curl -s "$API_URL" | jq -r '.[] | "\(.published_at) \(.tag_name)"' | grep " gwine-proton-[0-9]" | sort -r | head -n1 | cut -d' ' -f2)
    elif [ "$runner_choice" = "gwine-proton-wow64" ]; then
        wineversion=$(curl -s "$API_URL" | jq -r '.[] | "\(.published_at) \(.tag_name)"' | grep " gwine-proton-wow64-[0-9]" | sort -r | head -n1 | cut -d' ' -f2)
    else
        wineversion=$(curl -s "$API_URL" | jq -r '.[] | "\(.published_at) \(.tag_name)"' | grep " gwine-[0-9]" | sort -r | head -n1 | cut -d' ' -f2)
    fi
    if [ -z "$wineversion" ]; then
        kdialog --msgbox "Aucune version trouvée pour $runner_choice."
        exit 1
    fi
else
    wineversion="$soda_version"
fi

# Lancer la barre de progression avec kdialog et bouton Annuler
dbusRef=$(kdialog --title "Installation/Mise à jour de Windows" --progressbar "Initialisation..." 100)
qdbus $dbusRef showCancelButton true

# Fonction pour comparer les versions
version_newer() {
    local v1="$1" v2="$2"
    if [ "$v1" = "$v2" ]; then
        return 1 # égal
    fi
    [ "$(printf '%s\n' "$v1" "$v2" | sort -V | tail -n1)" = "$v1" ]
}

# Fonction pour récupérer et installer WINE
download_wine() {
    local target_dir="$1"
    local version="$2"
    local choice="$3"

    # Si la version demandée est déjà installée, pas de téléchargement
    if [ -d "$target_dir/$version" ]; then
        echo "Version $choice $version (dernière) déjà installée, téléchargement ignoré."
        return
    fi

    if [ -d "$target_dir" ] && ls "$target_dir"/* >/dev/null 2>&1; then
        current=$(ls -d "$target_dir"/* | grep -o '[a-z-]*-[0-9.r-]*' | head -n1)
        if [ -n "$current" ] && [ "$current" != "$version" ]; then
            echo "Mise à jour de $choice vers $version (sauvegarde de l'ancienne version $current)..."
            mkdir -p "$temp_dir/wine"
            if [ -d "$target_dir/$current" ]; then
                mv "$target_dir/$current" "$temp_dir/wine/"
            fi
            _install_wine "$target_dir" "$version" "$choice"
            need_rebuild=true
        else
            echo "Installation de $choice $version..."
            _install_wine "$target_dir" "$version" "$choice"
            need_rebuild=true
        fi
    else
        echo "Installation initiale de $choice $version..."
        _install_wine "$target_dir" "$version" "$choice"
        need_rebuild=true
    fi
}

_install_wine() {
    local target_dir="$1"
    local version="$2"
    local choice="$3"

    if [ "$choice" = "gwine" ] || [ "$choice" = "gwine-proton" ] || [ "$choice" = "gwine-proton-wow64" ]; then
        curl -L -o "$target_dir/$version.tar.xz" "https://github.com/elgabo86/gwine/releases/download/$version/$version.tar.xz"
        tar -xf "$target_dir/$version.tar.xz" -C "$target_dir/"
        rm -f "$target_dir/$version.tar.xz"
    else
        # Pour Soda, extraire dans un dossier temporaire et renommer
        temp_extract_dir="$temp_dir/wine_extract"
        mkdir -p "$temp_extract_dir"
        curl -L -o "$temp_extract_dir/$soda_version.tar.xz" "$soda_url"
        tar -xf "$temp_extract_dir/$soda_version.tar.xz" -C "$temp_extract_dir/"
        mv "$temp_extract_dir/$soda_version-x86_64" "$target_dir/$version"
        rm -f "$temp_extract_dir/$soda_version.tar.xz"
        rm -rf "$temp_extract_dir"
    fi
}

# Fonction générique pour télécharger un composant
download_component() {
    local name="$1"
    local version="$2"
    local target_dir="$3"
    local pattern="$4"
    local url="$5"
    local is_nvapi="$6"

    if [ -d "$target_dir/$version" ]; then
        echo "Version exacte de $name $version déjà présente, téléchargement ignoré."
        return
    fi

    if [ -d "$target_dir" ] && ls "$target_dir"/* >/dev/null 2>&1; then
        current=$(ls -d "$target_dir"/* 2>/dev/null | xargs -n1 basename 2>/dev/null | grep -E "$pattern" | head -n1)
        echo "$name détecté: '$current' (attendu: '$version')"
        if [ -n "$current" ] && [ -d "$target_dir/$current" ] && version_newer "$version" "$current"; then
            echo "Mise à jour de $name vers $version, sauvegarde de l'ancienne version ($current)..."
            _install_component "$name" "$version" "$target_dir" "$url" "$is_nvapi"
            mkdir -p "$temp_dir/${name,,}"
            mv "$target_dir/$current" "$temp_dir/${name,,}/"
            need_rebuild=true
        else
            echo "Version de $name $version déjà présente ou plus récente, téléchargement ignoré."
        fi
    else
        echo "Installation initiale de $name $version..."
        _install_component "$name" "$version" "$target_dir" "$url" "$is_nvapi"
        need_rebuild=true
    fi
}

_install_component() {
    local name="$1"
    local version="$2"
    local target_dir="$3"
    local url="$4"
    local is_nvapi="$5"

    if [ "$is_nvapi" = "true" ]; then
        # Extraction de la version à partir du nom (ex: dxvk-nvapi-v0.9.0 -> v0.9.0)
        version_tag=$(echo "$version" | sed 's/dxvk-nvapi-//')
        curl -L -o "$target_dir/$version.tar.gz" "$url"
        # Extraire dans un répertoire temporaire pour vérifier la structure de l'archive
        temp_extract_dir="$temp_dir/${name,,}_extract"
        mkdir -p "$temp_extract_dir"
        tar -xf "$target_dir/$version.tar.gz" -C "$temp_extract_dir/"
        # Vérifier si l'archive contient déjà un sous-dossier avec le nom de la version
        if [ -d "$temp_extract_dir/$version" ]; then
            mv "$temp_extract_dir/$version" "$target_dir/"
        else
            mkdir -p "$target_dir/$version"
            mv "$temp_extract_dir"/* "$target_dir/$version/"
        fi
        rm -f "$target_dir/$version.tar.gz"
        rm -rf "$temp_extract_dir"
    else
        curl -L -o "$target_dir/$version.tar.gz" "$url"
        tar -xf "$target_dir/$version.tar.gz" -C "$target_dir/"
        rm -f "$target_dir/$version.tar.gz"
    fi
}

# Fonction pour récupérer les programmes externes depuis bottle.yml
restore_external_programs() {
    local source_yml="$1"
    local target_yml="$2"

    if [ -f "$source_yml" ] && [ -f "$target_yml" ]; then
        /usr/bin/python3 - <<EOF
import yaml
import os

source_file = os.path.expanduser('$source_yml')
target_file = os.path.expanduser('$target_yml')

with open(source_file, 'r') as file:
    source_data = yaml.safe_load(file)
external_programs = source_data.get('External_Programs', {})

with open(target_file, 'r') as file:
    target_data = yaml.safe_load(file)
target_data['External_Programs'] = external_programs

with open(target_file, 'w') as file:
    yaml.safe_dump(target_data, file, default_flow_style=False, allow_unicode=True)
EOF
    fi
}

# Fonction pour restaurer les données de l'ancienne configuration
restore_config_data() {
    qdbus $dbusRef Set "" "value" 70
    qdbus $dbusRef setLabelText "Récupération des données de l'ancienne configuration..."
    _restore_config_dirs
    qdbus $dbusRef setLabelText "Récupération des programmes externes..."
    restore_external_programs \
        ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.bak/bottle.yml \
        ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def/bottle.yml
}

# Fonction interne pour restaurer les répertoires sans modifier la progression
_restore_config_dirs() {
    for dir in cache grids icons; do
        if [ -d ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.bak/$dir ]; then
            rm -rf ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def/$dir
            mv ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.bak/$dir ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def
        fi
    done
}

# Fonction pour restaurer les données dans le rebuild (sans modifier la progression)
restore_config_data_in_rebuild() {
    _restore_config_dirs
    restore_external_programs \
        ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.bak/bottle.yml \
        ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def/bottle.yml
}

# Fonction pour configurer Bottles (création, liens symboliques)
configure_bottles() {
    qdbus $dbusRef Set "" "value" 60
    qdbus $dbusRef setLabelText "Configuration de Bottles..."
    flatpak run --command=bottles-cli com.usebottles.bottles new --bottle-name "def" --runner "$wineversion" --environment gaming
    flatpak override com.usebottles.bottles --user --filesystem=~/Windows
    flatpak override com.usebottles.bottles --user --filesystem=/tmp
    mkdir -p ~/Windows/UserData ~/Windows/SteamData ~/Windows/Games ~/Windows/Applications ~/Windows/Tools ~/.local/share/applications
    rm -rf ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def/drive_c/users
    ln -s ~/Windows/UserData/ ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def/drive_c/users

    mkdir -p ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def/drive_c/ProgramData/

    ln -s ~/Windows/SteamData/ ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def/drive_c/ProgramData/Steam

    ln -s ~/Windows/Applications/ ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def/drive_c
    ln -s ~/Windows/Games/ ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def/drive_c
    ln -f -s -T ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def/drive_c/ ~/Windows/WinDrive
}

# Fonction pour ajouter les clés de registre
add_registry_keys() {
    qdbus $dbusRef Set "" "value" 70
    qdbus $dbusRef setLabelText "Ajout des clés de registre..."
    flatpak run --command=bottles-cli com.usebottles.bottles reg add -b def -k "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\winebus" -v "Enable SDL" -d 1 -t "REG_DWORD"
    flatpak run --command=bottles-cli com.usebottles.bottles reg add -b def -k "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\winebus" -v "DisableHidraw" -d 1 -t "REG_DWORD"
    flatpak run --command=bottles-cli com.usebottles.bottles reg add -b def -k "HKEY_CURRENT_USER\Software\Wine\Drivers" -v "Graphics" -d "X11" -t "REG_SZ"

    # Désactiver coremessaging.dll (fix wine proton)
    flatpak run --command=bottles-cli com.usebottles.bottles reg add -b def -k "HKEY_CURRENT_USER\Software\Wine\DllOverrides" -v "coremessaging" -d "" -t "REG_SZ"
}

# Fonction pour installer les runtimes
install_runtimes() {
    qdbus $dbusRef Set "" "value" 85
    qdbus $dbusRef setLabelText "Installation des runtimes..."
    flatpak run --env=WINEPREFIX=/var/data/bottles/bottles/def --env=WINE=/var/data/bottles/runners/"$wineversion"/bin/wine --command=/var/home/$user/Windows/Tools/winetricks com.usebottles.bottles -q \
        corefonts \
        tahoma \
        d3dcompiler_42 \
        d3dcompiler_43 \
        d3dcompiler_47 \
        d3dx9 \
        msls31 \
        vb6run \
        mfc42 \
        physx \
        quartz \
        vcrun2010 \
        vcrun2012 \
        vcrun2013 \
        vcrun2022 \
        dotnetdesktop6 \
        dotnetdesktop7 \
        dotnetdesktop8 \
        openal \
        xact
    flatpak run --env=WINEPREFIX=/var/data/bottles/bottles/def --env=WINE=/var/data/bottles/runners/"$wineversion"/bin/wine --command=/var/home/$user/Windows/Tools/winetricks com.usebottles.bottles -q settings fontsmooth=rgb
}

# Fonction pour finaliser la configuration (Flatpak runtimes, MangoHud, etc.)
finalize_runtimes_config() {
    qdbus $dbusRef Set "" "value" 90
    qdbus $dbusRef setLabelText "Finalisation des runtimes et configuration..."
    flatpak install runtime/org.freedesktop.Platform.VulkanLayer.MangoHud/x86_64/25.08 -y --system
    flatpak install runtime/com.obsproject.Studio.Plugin.OBSVkCapture/x86_64/stable -y --system
    flatpak install runtime/org.freedesktop.Platform.VulkanLayer.OBSVkCapture/x86_64/25.08 -y --system
    flatpak install runtime/org.freedesktop.Platform.VulkanLayer.gamescope/x86_64/25.08 -y --system
    mkdir -p ~/.config/MangoHud
    cp /usr/share/ublue-os/gablue/MangoHud.conf ~/.config/MangoHud
    flatpak run --command=bottles-cli com.usebottles.bottles edit -b def --params mangohud:true
    flatpak run --command=bottles-cli com.usebottles.bottles edit -b def --params gamemode:true
    mkdir -p ~/Windows/UserData/Public/Documents/Steam

    if [ -e "$dossieruser" ]; then
        if [ ! -e "~/Windows/UserData/steamuser" ]; then
            ln -s "./$user" "~/Windows/UserData/steamuser"
        fi
    else
        if [ -e "~/Windows/UserData/steamuser" ]; then
            ln -s "./steamuser" "$dossieruser"
        fi
    fi
}

# Fonction pour finaliser le rebuild
finalize_rebuild() {
    qdbus $dbusRef setLabelText "Création de la bouteille prête (bak/def.ready)..."
    rm -rf ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.ready
    cp -r ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.ready
}

# Fonction pour configurer les raccourcis et outils
configure_shortcuts_tools() {
    qdbus $dbusRef Set "" "value" 80
    qdbus $dbusRef setLabelText "Configuration des raccourcis et outils..."
    cp /usr/share/ublue-os/gablue/desktops/com.usebottles.bottles.desktop ~/.local/share/applications
    cp /usr/share/ublue-os/gablue/desktops/Windows.desktop ~/.local/share/applications
    cp /usr/share/ublue-os/gablue/desktops/WindowsFix.desktop ~/.local/share/applications
    cp /usr/share/ublue-os/gablue/desktops/WindowsTerminal.desktop ~/.local/share/applications
    cp /usr/share/ublue-os/gablue/desktops/KillWindows.desktop ~/.local/share/applications
    mkdir -p ~/.local/share/kio/servicemenus
    cp /usr/share/ublue-os/gablue/desktops/servicemenus/CreateWinShortcut.desktop ~/.local/share/kio/servicemenus
    cp /usr/share/ublue-os/gablue/desktops/servicemenus/LaunchWin.desktop ~/.local/share/kio/servicemenus
    cp /usr/share/ublue-os/gablue/desktops/servicemenus/InstallWinReg.desktop ~/.local/share/kio/servicemenus
    cp /usr/share/ublue-os/gablue/desktops/servicemenus/CreateWGP.desktop ~/.local/share/kio/servicemenus
    cp /usr/share/ublue-os/gablue/desktops/servicemenus/EditWGP.desktop ~/.local/share/kio/servicemenus
    mkdir -p ~/.local/share/mime/packages/
    cp /usr/share/ublue-os/gablue/desktops/mime/wgp-mime.xml ~/.local/share/mime/packages/
    mkdir -p ~/.local/share/thumbnailers
    cp /usr/share/ublue-os/gablue/desktops/thumbnailers/wgp.thumbnailer ~/.local/share/thumbnailers
    mkdir -p ~/.local/bin
    cp /usr/share/ublue-os/gablue/bin/wgp-thumbnailer ~/.local/bin
    chmod +x ~/.local/bin/wgp-thumbnailer
    update-mime-database ~/.local/share/mime
    update-desktop-database ~/.local/share/applications
    xdg-mime default Windows.desktop application/x-ms-dos-executable
    xdg-mime default Windows.desktop application/x-msi
    xdg-mime default Windows.desktop application/x-ms-shortcut
    xdg-mime default Windows.desktop application/x-wine-extension-msp
    xdg-mime default Windows.desktop application/x-bat
    xdg-mime default Windows.desktop application/x-wgp
    mkdir -p ~/Windows/Tools
    for file in ~/Windows/Tools/*; do
        if [ -f "$file" ] && [ "$(basename "$file")" != "winetricks" ]; then
            rm -f "$file"
        fi
    done
    wget -O ~/Windows/Tools/winetricks https://raw.githubusercontent.com/Winetricks/winetricks/master/src/winetricks
    chmod +x ~/Windows/Tools/winetricks
}

# Fonction pour gérer les erreurs, annulations ou Ctrl+C
cleanup() {
    set +e
    rm -f "$flag_file"
    if [ -n "$monitor_pid" ]; then
        kill "$monitor_pid" 2>/dev/null
        sleep 0.5
    fi
    if pgrep -f bottles > /dev/null; then
        pgrep -f bottles | xargs -n1 kill -9 &
        sleep 1
    fi
    qdbus $dbusRef setLabelText "Annulation ou erreur détectée, restauration de l'ancienne version..." 2>/dev/null
    for component in wine dxvk vkd3d nvapi latencyflex; do
        if [ -d "$temp_dir/$component" ]; then
            target_dir=""
            case $component in
                wine) target_dir=~/.var/app/com.usebottles.bottles/data/bottles/runners/ ;;
                dxvk) target_dir=~/.var/app/com.usebottles.bottles/data/bottles/dxvk/ ;;
                vkd3d) target_dir=~/.var/app/com.usebottles.bottles/data/bottles/vkd3d/ ;;
                nvapi) target_dir=~/.var/app/com.usebottles.bottles/data/bottles/nvapi/ ;;
                latencyflex) target_dir=~/.var/app/com.usebottles.bottles/data/bottles/latencyflex/ ;;
            esac
            rm -rf "$target_dir"/*
            mv "$temp_dir/$component"/* "$target_dir/"
        fi
    done
    rm -rf "$temp_dir"
    rm -rf ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def
    if [ -d ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.bak ]; then
        mv ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.bak ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def
    fi
    qdbus $dbusRef close 2>/dev/null
    kdialog --msgbox "Opération annulée ou erreur survenue. L'ancienne bouteille est restaurée." 2>/dev/null
    exit 1
}

# Capturer les erreurs et Ctrl+C
trap 'cleanup' ERR INT

# Surveiller le bouton Annuler en arrière-plan avec un fichier drapeau
(
    while [ -f "$flag_file" ]; do
        if ! qdbus $dbusRef >/dev/null 2>&1; then
            echo "Service DBus fermé, annulation détectée"
            cleanup
        fi
        cancelled=$(qdbus $dbusRef wasCancelled 2>/dev/null)
        if [ "$cancelled" = "true" ]; then
            echo "Annuler détecté via wasCancelled"
            cleanup
        fi
        sleep 1
    done
) & monitor_pid=$!

qdbus $dbusRef Set "" "value" 0
qdbus $dbusRef setLabelText "Arrêt des processus bottles..."

if pgrep -f bottles > /dev/null; then
    pgrep -f bottles | xargs -n1 kill -9 &
    sleep 2
fi

qdbus $dbusRef Set "" "value" 5
qdbus $dbusRef setLabelText "Préparation des répertoires..."
mkdir -p ~/.var/app/com.usebottles.bottles/data/bottles/bak
if [ -d ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def ]; then
    rm -rf ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.bak
    mv ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.bak
fi
mkdir -p ~/.var/app/com.usebottles.bottles/data/bottles/dxvk/ ~/.var/app/com.usebottles.bottles/data/bottles/runners/ ~/.var/app/com.usebottles.bottles/data/bottles/vkd3d/ ~/.var/app/com.usebottles.bottles/data/bottles/nvapi/ ~/.var/app/com.usebottles.bottles/data/bottles/latencyflex

# Vérification des versions actuelles
need_rebuild=false
wine_dir=~/.var/app/com.usebottles.bottles/data/bottles/runners
dxvk_dir=~/.var/app/com.usebottles.bottles/data/bottles/dxvk
vkd3d_dir=~/.var/app/com.usebottles.bottles/data/bottles/vkd3d
nvapi_dir=~/.var/app/com.usebottles.bottles/data/bottles/nvapi
latencyflex_dir=~/.var/app/com.usebottles.bottles/data/bottles/latencyflex
bottle_yml=~/.var/app/com.usebottles.bottles/data/bottles/bak/def.bak/bottle.yml

# Vérification si def.ready existe et comparaison du runner actuel avec celui dans bottle.yml
if [ "$force_rebuild" = true ]; then
    echo "Argument --rebuild détecté, rebuild forcé."
    need_rebuild=true
elif [ ! -d ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.ready ]; then
    echo "def.ready n'existe pas, rebuild requis."
    need_rebuild=true
elif [ -f "$bottle_yml" ]; then
    current_runner=$(grep "Runner:" "$bottle_yml" | awk '{print $2}' | tr -d '"')
    echo "Runner actuel dans bottle.yml : $current_runner"
    echo "Runner choisi : $wineversion"
    if [ -n "$current_runner" ] && [ "$current_runner" != "$wineversion" ]; then
        echo "Le runner actuel ($current_runner) diffère du choisi ($wineversion), rebuild requis."
        need_rebuild=true
    else
        echo "Le runner actuel ($current_runner) est identique au choisi ($wineversion), vérification de son existence..."
        if [ ! -d "$wine_dir/$wineversion" ]; then
            echo "Le runner $wineversion n'est pas installé dans $wine_dir, téléchargement requis."
            need_rebuild=true
        else
            echo "Le runner $wineversion est déjà installé, pas de rebuild nécessaire pour ce critère."
        fi
    fi
else
    echo "bottle.yml non trouvé dans bak/def.bak/, rebuild requis par précaution."
    need_rebuild=true
fi

# Proposer de forcer le rebuild si pas nécessaire
if [ "$need_rebuild" = false ]; then
    if kdialog --title "Rebuild" --yesno "Aucune mise à jour de composant détectée.\nVoulez-vous tout de même refaire le rebuild complet ?"; then
        need_rebuild=true
    fi
fi

# Vérification et téléchargement des composants avec sauvegarde des anciennes versions
qdbus $dbusRef Set "" "value" 10
download_wine "$wine_dir" "$wineversion" "$runner_choice"

qdbus $dbusRef Set "" "value" 20
download_component "DXVK" "$dxvkversion" "$dxvk_dir" "^dxvk-gplasync-v[0-9.-]+" "https://gitlab.com/Ph42oN/dxvk-gplasync/-/raw/main/releases/$dxvkversion.tar.gz" "false"

qdbus $dbusRef Set "" "value" 30
download_component "VKD3D" "$vkd3dversion" "$vkd3d_dir" "^vkd3d-proton-[0-9.-]+" "https://github.com/bottlesdevs/components/releases/download/$vkd3dversion/$vkd3dversion.tar.gz" "false"

qdbus $dbusRef Set "" "value" 40
nvapi_version_tag=$(echo "$nvapiversion" | sed 's/dxvk-nvapi-//')
download_component "dxvk-nvapi" "$nvapiversion" "$nvapi_dir" "^dxvk-nvapi-v[0-9.-]+" "https://github.com/jp7677/dxvk-nvapi/releases/download/$nvapi_version_tag/$nvapiversion.tar.gz" "true"

qdbus $dbusRef Set "" "value" 50
download_component "LatencyFlex" "$latencyflexversion" "$latencyflex_dir" "^latencyflex-v[0-9.-]+[-a-z0-9]*" "https://github.com/bottlesdevs/components/releases/download/$latencyflexversion/$latencyflexversion.tar.gz" "false"

if [ "$need_rebuild" = false ]; then
    qdbus $dbusRef Set "" "value" 60
    qdbus $dbusRef setLabelText "Restauration de la bouteille prête depuis bak/def.ready..."
    rm -rf ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def
    cp -r ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.ready ~/.var/app/com.usebottles.bottles/data/bottles/bottles/def

    restore_config_data

    rm -rf ~/.var/app/com.usebottles.bottles/data/bottles/bak/def.bak
    rm -rf "$temp_dir"
    qdbus $dbusRef Set "" "value" 100
    qdbus $dbusRef setLabelText "Finalisation..."
    qdbus $dbusRef close 2>/dev/null
    rm -f "$flag_file"
    if [ -n "$monitor_pid" ]; then
        kill "$monitor_pid" 2>/dev/null
        sleep 0.5
    fi
    kdialog --msgbox "L'installation/mise à jour de Windows est réussie." 2>/dev/null
    exit 0
fi

if [ "$need_rebuild" = true ]; then
    configure_bottles
    add_registry_keys
    configure_shortcuts_tools
    install_runtimes
    finalize_runtimes_config

    qdbus $dbusRef Set "" "value" 95
    qdbus $dbusRef setLabelText "Récupération des données de l'ancienne configuration..."
    restore_config_data_in_rebuild

    finalize_rebuild
fi

rm -rf "$temp_dir"
qdbus $dbusRef Set "" "value" 100
qdbus $dbusRef setLabelText "Finalisation..."
qdbus $dbusRef close 2>/dev/null
rm -f "$flag_file"
if [ -n "$monitor_pid" ]; then
    kill "$monitor_pid" 2>/dev/null
    sleep 0.5
fi
if [ -f ~/.var/app/com.usebottles.bottles/data/bottles/library.yml ]; then
    /usr/bin/bottles-sort-library
fi
kdialog --msgbox "L'installation/mise à jour de Windows est réussie." 2>/dev/null
rm -f "$flag_file"
