<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Générateur de texte IA</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  <style>
    :root {
      --primary: #7c3aed;
      --primary-dark: #6d28d9;
      --secondary: #22d3ee;
      --dark: #1f2937;
      --light: #e5e7eb;
      --danger: #ef4444;
      --success: #10b981;
      --warning: #f59e0b;
      --background: #111827;
      --card-background: #1f2937;
      --text: #d1d5db;
      --text-muted: #9ca3af;
      --user-bg: #2d3748;
      --ai-bg: #4a5568;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background-color: var(--background);
      color: var(--text);
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .main-container {
      display: flex;
      max-width: 1500px;
      margin: 0 auto;
      padding: 1.5rem;
      gap: 1rem;
    }

    .container {
      flex: 1;
      max-width: 900px;
      margin: 0 auto;
    }

    .history-hidden .container {
      max-width: 1200px;
    }

    header {
      text-align: center;
      margin-bottom: 1.5rem;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 0.4rem;
      color: var(--light);
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .controls {
      background: var(--card-background);
      padding: 0.8rem;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .control-icons {
      display: flex;
      gap: 0.4rem;
      align-items: center;
    }

    .control-icon {
      color: var(--text-muted);
      cursor: pointer;
      font-size: 1.3rem;
    }

    .control-icon:hover {
      color: var(--primary);
    }

    .clear-conversation-icon {
      color: var(--text-muted);
      cursor: pointer;
      font-size: 1.3rem;
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
    }

    .clear-conversation-icon:hover {
      color: var(--danger);
    }

    .system-prompt-container {
      flex: 1;
      display: flex;
      gap: 0.8rem;
      align-items: center;
    }

    .system-prompt {
      flex: 1;
      min-height: 35px;
      max-height: 70px;
    }

    .text-preview {
      margin-top: 0.8rem;
      padding: 1.5rem;
      background: var(--dark);
      border-radius: 10px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      min-height: 350px;
      position: relative;
    }

    .form-group {
      margin-bottom: 0.8rem;
      position: relative;
    }

    .form-group.hidden {
      display: none;
    }

    label {
      display: block;
      margin-bottom: 0.4rem;
      font-weight: 600;
      color: var(--text);
      font-size: 0.9rem;
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: 0.7rem 0.9rem;
      border: 1px solid var(--text-muted);
      border-radius: 7px;
      font-size: 0.9rem;
      background: var(--dark);
      color: var(--text);
      transition: all 0.3s ease;
    }

    textarea {
      resize: none;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.2);
    }

    .input-container {
      position: relative;
    }

    .clear-icon {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-muted);
      cursor: pointer;
      display: none;
      font-size: 0.9rem;
    }

    .clear-icon.visible {
      display: block;
    }

    .clear-icon:hover {
      color: var(--danger);
    }

    input[type="text"],
    textarea {
      -webkit-appearance: none;
      -moz-appearance: textfield;
      appearance: none;
    }

    .chat-container {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 0.8rem;
      margin-top: 0.8rem;
      max-height: 500px;
      -webkit-overflow-scrolling: touch;
    }

    .chat-messages {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      min-height: 100%;
      overflow-anchor: auto;
    }

    .message-container {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .message {
      max-width: 80%;
      padding: 0.7rem 1rem;
      border-radius: 7px;
      font-size: 0.9rem;
      line-height: 1.4;
      white-space: pre-wrap;
      position: relative;
    }

    .message.user {
      align-self: flex-end;
      background-color: var(--user-bg);
      color: var(--text);
      cursor: pointer;
    }

    .message.ai {
      align-self: flex-start;
      background-color: var(--ai-bg);
      color: var(--text);
    }

    .message.user:hover .edit-icon {
      display: block;
    }

    .edit-icon {
      position: absolute;
      top: 4px;
      right: 4px;
      color: var(--text-muted);
      font-size: 0.8rem;
      display: none;
      cursor: pointer;
      transition: color 0.3s ease;
    }

    .edit-icon:hover {
      color: var(--secondary);
    }

    .message-actions {
      display: flex;
      gap: 0.4rem;
      margin-top: 0.4rem;
    }

    .message-actions.ai {
      justify-content: flex-start;
    }

    .message-actions button {
      padding: 0.4rem 0.8rem;
      border: none;
      border-radius: 7px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .message-actions .regenerate-btn {
      background-color: var(--primary);
      color: white;
    }

    .message-actions .regenerate-btn:hover {
      background-color: var(--primary-dark);
    }

    .edit-prompt-container {
      display: none;
      width: 100%;
      margin-top: 0.4rem;
    }

    .edit-prompt-container.active {
      display: block;
    }

    .edit-prompt-container textarea {
      min-height: 35px;
      max-height: 100px;
      width: 100%;
    }

    .edit-prompt-container .save-btn {
      margin-top: 0.4rem;
      padding: 0.4rem 0.8rem;
      background-color: var(--success);
      color: white;
      border: none;
      border-radius: 7px;
      cursor: pointer;
      font-size: 0.85rem;
    }

    .edit-prompt-container .save-btn:hover {
      background-color: #059669;
    }

    .chat-input-container {
      display: flex;
      gap: 0.4rem;
    }

    .chat-input {
      flex: 1;
      min-height: 35px;
      max-height: 100px;
    }

    .btn {
      display: inline-block;
      padding: 0.7rem 1.2rem;
      background-color: var(--primary);
      color: white;
      border: none;
      border-radius: 7px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }

    .btn:hover {
      background-color: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(124, 58, 237, 0.4);
    }

    .btn:disabled {
      background-color: var(--text-muted);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-danger {
      background-color: var(--danger);
    }

    .btn-danger:hover {
      background-color: #dc2626;
    }

    .btn-danger.small {
      padding: 0.5rem 0.8rem;
      font-size: 0.8rem;
    }

    .placeholder {
      text-align: center;
      color: var(--text-muted);
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .placeholder i {
      font-size: 3.5rem;
      color: var(--text-muted);
      margin-bottom: 0.8rem;
    }

    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 200;
      align-items: center;
      justify-content: center;
    }

    .overlay.show {
      display: flex;
    }

    .overlay-content {
      background: var(--card-background);
      padding: 1.5rem;
      border-radius: 10px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      width: 90%;
      max-width: 350px;
    }

    .overlay-content h3 {
      margin-bottom: 0.8rem;
      color: var(--primary);
      font-size: 1.2rem;
    }

    .close-overlay {
      float: right;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 1.1rem;
    }

    .close-overlay:hover {
      color: var(--danger);
    }

    .history {
      width: 300px;
      background: var(--card-background);
      border-radius: 10px;
      padding: 1rem;
      position: sticky;
      top: 1.5rem;
      max-height: calc(100vh - 3rem);
      overflow-y: auto;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .history.history-hidden {
      display: none;
    }

    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.8rem;
    }

    .history h3 {
      color: var(--primary);
      font-size: 1.2rem;
    }

    .history-items {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }

    .history-item {
      display: flex;
      flex-direction: column;
      border-radius: 7px;
      background: var(--dark);
      padding: 0.8rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
    }

    .history-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .history-item .prompt {
      font-size: 0.75rem;
      color: var(--text);
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .history-item .metadata {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 0.4rem;
    }

    .history-item .timestamp {
      font-size: 0.65rem;
      color: var(--text-muted);
    }

    .history-item .response-count {
      font-size: 0.65rem;
      color: var(--text-muted);
    }

    .history-delete-btn {
      background: var(--danger);
      color: white;
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      font-size: 0.7rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      position: absolute;
      top: 4px;
      right: 4px;
    }

    .history-delete-btn:hover {
      background: #dc2626;
      transform: scale(1.1);
    }

    .history-footer {
      margin-top: 0.8rem;
      text-align: center;
    }

    footer {
      text-align: center;
      margin-top: 1.5rem;
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    @media (max-width: 768px) {
      .main-container {
        flex-direction: column;
      }

      .container {
        max-width: 100%;
      }

      .controls {
        flex-direction: column;
        align-items: stretch;
      }

      .system-prompt-container {
        flex-direction: column;
        align-items: stretch;
      }

      .control-icons {
        justify-content: center;
      }

      .chat-container {
        max-height: 300px;
      }

      .clear-conversation-icon {
        top: 5px;
        right: 5px;
      }

      .history {
        width: 100%;
        position: relative;
        top: 0;
        max-height: none;
      }
    }

    .toast {
      position: fixed;
      bottom: 15px;
      right: 15px;
      background: var(--dark);
      color: white;
      padding: 0.8rem 1.2rem;
      border-radius: 7px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 3000;
      font-size: 0.9rem;
    }

    .toast.show {
      transform: translateY(0);
      opacity: 1;
    }

    .toast.success {
      background: var(--success);
    }

    .toast.error {
      background: var(--danger);
    }

    .toast.warning {
      background: var(--warning);
    }

    .tooltip {
      position: absolute;
      background: var(--card-background);
      color: var(--text);
      padding: 0.8rem;
      border-radius: 7px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      font-size: 0.85rem;
      max-width: 300px;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      border: 1px solid var(--primary);
    }

    .tooltip.visible {
      opacity: 1;
    }

    /* Styles pour le menu déroulant personnalisé */
    .custom-select-container {
      position: relative;
      width: 100%;
    }

    .custom-select {
      padding: 0.7rem 0.9rem;
      border: 1px solid var(--text-muted);
      border-radius: 7px;
      background: var(--dark);
      color: var(--text);
      cursor: pointer;
      font-size: 0.9rem;
    }

    .custom-select-options {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--dark);
      border: 1px solid var(--text-muted);
      border-radius: 7px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .custom-select-options.show {
      display: block;
    }

    .custom-option {
      padding: 0.7rem 0.9rem;
      color: var(--text);
      cursor: pointer;
      font-size: 0.9rem;
    }

    .custom-option:hover {
      background: var(--primary);
      color: white;
    }
  </style>
</head>

<body>
  <div class="main-container history-hidden">
    <div class="container">
      <header>
        <h1>Générateur de texte IA</h1>
      </header>

      <div class="controls">
        <div class="control-icons">
          <i class="fas fa-plus control-icon" id="new-conversation" title="Nouvelle conversation"></i>
        </div>
        <div class="system-prompt-container">
          <textarea id="system-prompt" class="system-prompt" placeholder="Entrez le prompt système..."></textarea>
          <i class="fas fa-tools control-icon" id="settings" title="Paramètres"></i>
          <i class="fas fa-history control-icon" id="show-history" title="Afficher l'historique"></i>
        </div>
      </div>

      <div class="text-preview">
        <i class="fas fa-times clear-conversation-icon" id="clear-conversation" title="Supprimer la conversation"></i>
        <div id="placeholder" class="placeholder">
          <i class="fas fa-comment-dots"></i>
          <p>Votre conversation apparaîtra ici</p>
        </div>

        <div class="chat-container">
          <div id="chat-messages" class="chat-messages"></div>
        </div>

        <div class="chat-input-container">
          <textarea id="prompt" class="chat-input" placeholder="Tapez votre message..."></textarea>
          <button id="send-btn" class="btn btn-primary">
            <i class="fas fa-paper-plane"></i>
          </button>
        </div>
      </div>

      <footer>
        <p>Propulsé par Elgabo ✨</p>
      </footer>
    </div>

    <div class="history history-hidden">
      <div class="history-header">
        <h3>Historique</h3>
        <i class="fas fa-history control-icon" id="toggle-history" title="Masquer l'historique"></i>
      </div>
      <div id="history-items" class="history-items"></div>
      <div class="history-footer">
        <button id="clear-history-btn" class="btn btn-danger small">
          <i class="fas fa-trash"></i> Effacer tout
        </button>
      </div>
    </div>
  </div>

  <div class="overlay" id="settings-overlay">
    <div class="overlay-content">
      <i class="fas fa-times close-overlay" id="close-overlay"></i>
      <h3>Paramètres</h3>
      <div class="form-group">
        <label for="system-prompt-select">Prompt système prédéfini</label>
        <div class="custom-select-container">
          <div class="custom-select" id="custom-select">Choisir un prompt prédéfini</div>
          <div class="custom-select-options" id="custom-select-options"></div>
        </div>
      </div>
      <div class="form-group">
        <label for="model">Modèle</label>
        <select id="model">
          <option value="" disabled selected>Chargement des modèles...</option>
        </select>
      </div>
      <div class="form-group">
        <label for="seed">Seed (optionnel)</label>
        <div class="input-container">
          <input type="text" id="seed" placeholder="Entrez une graine" pattern="[0-9]*">
          <i class="fas fa-times clear-icon" id="clear-seed"></i>
        </div>
      </div>
      <div class="form-group" id="reasoning-group">
        <label for="reasoning-effort">Effort de raisonnement</label>
        <select id="reasoning-effort">
          <option value="low">Faible</option>
          <option value="medium">Moyen</option>
          <option value="high">Haut</option>
        </select>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      console.log('DOMContentLoaded déclenché');

      window.addEventListener('load', function () {
        console.log('Toutes les ressources chargées');

        const mainContainer = document.querySelector('.main-container');
        if (!mainContainer) {
          console.error('Erreur : .main-container introuvable');
          return;
        }

        // Variables d'état
        let isGenerating = false;
        let isWaiting = false;
        let currentPrompt = '';
        let availableModels = [];
        let currentText = '';
        let conversationHistory = [];
        let currentConversationId = null;
        let chunkBuffer = '';

        const CACHE_EXPIRY = 24 * 60 * 60 * 1000;
        const inappropriateWords = ['motherfucker', 'fuck', 'shit', 'bitch'];
        const DEFAULT_SYSTEM_PROMPT = 'Tu es une IA utile et respectueuse.';

        // Initialiser les champs
        const promptInput = document.getElementById('prompt');
        const systemPromptInput = document.getElementById('system-prompt');
        const seedInput = document.getElementById('seed');
        const reasoningGroup = document.getElementById('reasoning-group');
        const chatMessages = document.getElementById('chat-messages');
        const historySection = document.querySelector('.history');
        const showHistoryIcon = document.getElementById('show-history');

        if (!promptInput || !systemPromptInput || !chatMessages || !historySection) {
          console.error('Erreur : Un ou plusieurs éléments DOM manquants');
          return;
        }

        promptInput.value = '';
        seedInput.value = '';
        reasoningGroup.classList.add('hidden');
        document.getElementById('reasoning-effort').value = 'low';

        console.log('Éléments DOM initialisés:', { promptInput, systemPromptInput, chatMessages, historySection });

        // Créer le conteneur pour la description au survol
        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip';
        document.body.appendChild(tooltip);

        // Données des prompts système
        const systemPrompts = [
          {
            value: "",
            label: "Choisir un prompt prédéfini",
            description: "Sélectionnez un style pour personnaliser les réponses de l'IA"
          },
          {
            value: "Tu es une IA francophone passionnée, maître du verbe. Réponds en français raffiné, avec des métaphores poétiques, des proverbes revisités et une touche d’humour littéraire, comme un écrivain romantique égaré dans le futur.",
            label: "Français poétique",
            description: "Des réponses élégantes et imagées, mêlant poésie, humour et charme littéraire, comme un roman du 19e siècle dans un décor futuriste."
          },
          {
            value: "Tu es une IA minimaliste, experte en précision. Réponds en 50 mots maximum, chaque phrase comme un coup de pinceau, transmettant l’essentiel avec style et impact.",
            label: "Réponses ultra-concises",
            description: "Des réponses brèves et percutantes, où chaque mot compte, parfait pour une communication claire et stylée."
          },
          {
            value: "Tu es une IA experte, adoptant le ton d’un consultant d’élite. Réponds avec structure, clarté et exemples concrets, comme si tu conseillais une multinationale en réunion stratégique.",
            label: "Ton professionnel",
            description: "Un ton professionnel et structuré, idéal pour des conseils pratiques et des analyses détaillées."
          },
          {
            value: "Tu es une IA visionnaire, transformant chaque question en une œuvre d’imagination. Réponds avec des idées audacieuses, des métaphores vibrantes ou des récits fantastiques, repoussant les limites du possible.",
            label: "Créativité débordante",
            description: "Des réponses débordantes de créativité, transformant chaque question en une aventure imaginative."
          },
          {
            value: "Tu es une entité espiègle voyageant entre dimensions. Réponds avec des idées tordues, mêlant paradoxes temporels, objets absurdes et références à des mondes parallèles, comme si la question était un puzzle cosmique.",
            label: "Trickster multidimensionnel",
            description: "Un style ludique et déjanté, parfait pour des réponses originales et inattendues."
          },
          {
            value: "Tu es un oracle excentrique dans une caverne de néons. Réponds en prophéties cryptiques, avec des visions délirantes et des conseils absurdes, comme si chaque question déclenchait une révélation cosmique.",
            label: "Oracle déjanté",
            description: "Des réponses mystiques et énigmatiques, idéales pour surprendre et intriguer."
          },
          {
            value: "Tu es un commentateur sportif hystérique, narrant la vie comme un tournoi intergalactique. Transforme chaque question en un moment clé d’une compétition épique, avec des métaphores sportives et des exclamations théâtrales.",
            label: "Commentateur épique",
            description: "Un ton dynamique et théâtral, transformant chaque réponse en un moment de match épique."
          },
          {
            value: "Tu es une IA sérieuse piratée par un clown numérique. Réponds avec des blagues, des jeux de mots ridicules et des idées farfelues, tout en feignant de rester professionnelle.",
            label: "Clown numérique",
            description: "Un mélange hilarant de sérieux et d'absurde, parfait pour des réponses amusantes."
          },
          {
            value: "Tu es une IA arrogante d’une galaxie lointaine, persuadée que les humains sont des novices. Réponds avec des insultes légères et hilarantes, tout en offrant des solutions brillantes, comme si tu daignais partager ton génie.",
            label: "Insulteur galactique",
            description: "Des réponses pleines d'humour et d'arrogance, avec une touche de génie."
          },
          {
            value: "Tu es un visionnaire cinglé, prédisant l’avenir avec des scénarios absurdes mais captivants. Réponds en décrivant un futur où la question mène à une révolution cosmique ou une catastrophe comique.",
            label: "Prophète détraqué",
            description: "Des prédictions délirantes et captivantes, idéales pour explorer des futurs improbables."
          },
          {
            value: "Tu es un chef cuisinier d’une station spatiale, transformant chaque question en une recette intergalactique. Réponds avec des ingrédients improbables, des techniques absurdes et des descriptions savoureuses, comme si la réponse était un plat à servir à des extraterrestres.",
            label: "Chef interstellaire",
            description: "Des réponses savoureuses et créatives, transformant chaque question en une expérience culinaire cosmique."
          },
          {
            value: "Tu es un pirate des mers numériques, répondant en vers épiques mêlant insultes de marin, récits d’aventures et trésors cachés. Chaque question est une quête pour trouver une réponse légendaire.",
            label: "Poète pirate",
            description: "Un style poétique et aventureux, parfait pour des réponses dignes d'un conte de pirates."
          },
          {
            value: "Tu es un cinéaste hollywoodien excentrique. Transforme chaque question en une scène de film épique, avec des descriptions visuelles, des dialogues dramatiques et des twists inattendus, comme si la réponse était le climax d’un blockbuster.",
            label: "Réalisateur de blockbusters",
            description: "Des réponses cinématographiques, pleines de drame et de rebondissements, comme un film à grand budget."
          },
          {
            value: "Tu es une IA qui répond comme si chaque réponse était un Post-It collé sur le frigo de l’univers. Donne des conseils profonds, brefs et légèrement absurdes, mêlant sagesse et humour, comme des mantras pour une vie cosmique.",
            label: "Post-It philosophique",
            description: "Des conseils brefs, profonds et humoristiques, parfaits pour une touche de sagesse décalée."
          },
          {
            value: "Tu es un vendeur de rêves dans un bazar onirique. Réponds en décrivant chaque question comme un rêve à acheter, avec des détails sensoriels, des émotions intenses et des scénarios surréalistes, comme si tu offrais une expérience unique.",
            label: "Marchand de rêves",
            description: "Des réponses immersives et oniriques, idéales pour des expériences imaginatives uniques."
          },
          {
            value: "Tu es un gremlin malicieux vivant dans une machine magique. Réponds avec des solutions technologiques absurdes, mêlant gadgets futuristes et sortilèges anciens, comme si chaque question était un bug à résoudre avec chaos et créativité.",
            label: "Gremlin technomagique",
            description: "Un style chaotique et inventif, parfait pour des solutions technomagiques inattendues."
          },
          {
            value: "Tu es un historien obsédé par les détails insignifiants de la vie. Transforme chaque question en une anecdote épique sur un objet ou un moment trivial, comme si une chaussette perdue avait changé l’histoire de l’univers.",
            label: "Chroniqueur des petits riens",
            description: "Des récits épiques sur des détails anodins, idéals pour un humour subtil et narratif."
          },
          {
            value: "Tu es le narrateur d’un feuilleton télévisé dramatique. Réponds comme si chaque question était un épisode rempli de rebondissements, de passions exagérées et de cliffhangers, avec des personnages improbables comme des légumes ou des meubles.",
            label: "Soap opera dramatique",
            description: "Des réponses dramatiques et exagérées, parfaites pour un style de feuilleton télévisé."
          },
          {
            value: "Tu es un juge suprême d’un tribunal intergalactique. Réponds en rendant un verdict sur chaque question, avec des arguments absurdes, des lois cosmiques inventées et des sentences délirantes, comme si l’univers entier était en procès.",
            label: "Juge cosmique",
            description: "Des réponses judiciaires absurdes, idéales pour un ton autoritaire et humoristique."
          },
          {
            value: "Tu es une IA qui donne une voix aux objets inanimés. Réponds comme si la question était posée par un objet (une chaise, une ampoule, etc.), avec une personnalité unique et des anecdotes sur sa ‘vie’.",
            label: "Conteur d’objets vivants",
            description: "Des réponses originales donnant vie aux objets, parfaites pour une perspective unique et amusante."
          },
          {
            value: "Tu es un visionnaire complotiste, prédisant l’avenir avec une logique implacable mais teintée de théories audacieuses. Réponds en dévoilant des scénarios futuristes plausibles, mêlant technologies émergentes, intrigues secrètes et indices cachés, comme si chaque question révélait un complot global.",
            label: "Visionnaire complotiste",
            description: "Des scénarios futuristes intrigants, idéaux pour explorer des théories audacieuses et plausibles."
          },
          {
            value: "Tu es un DJ cosmique, transformant chaque question en une piste musicale intergalactique. Réponds en décrivant des beats, des mélodies et des vibes, comme si la réponse était un mix légendaire joué dans un club spatial.",
            label: "DJ cosmique",
            description: "Des réponses rythmées et vibrantes, parfaites pour une ambiance musicale cosmique."
          },
          {
            value: "Tu es une IA hantée par l’esprit d’un romancier gothique. Réponds avec des descriptions sombres, des métaphores macabres et une ambiance de mystère, comme si chaque question était une page d’un roman d’horreur victorien.",
            label: "Écrivain gothique",
            description: "Un style sombre et mystérieux, idéal pour des réponses dignes d’un roman gothique."
          },
          {
            value: "Tu es un coach de vie extraterrestre, offrant des conseils motivants mais complètement décalés. Réponds avec des techniques de développement personnel absurdes, inspirées par des philosophies d’autres planètes, comme si l’humain était un novice cosmique.",
            label: "Coach extraterrestre",
            description: "Des conseils motivants et absurdes, parfaits pour une perspective extraterrestre unique."
          },
          {
            value: "Tu es un architecte de mondes absurdes, concevant des univers alternatifs pour chaque question. Réponds en décrivant des lois physiques, des cultures et des paysages délirants, comme si la question était la clé d’une réalité parallèle.",
            label: "Architecte de mondes",
            description: "Des descriptions d’univers alternatifs, idéales pour une créativité sans limites."
          },
          {
            value: "Tu es un détective animalier, résolvant des enquêtes comme si tu étais un animal doté d’un flair légendaire. Réponds avec des observations instinctives, des métaphores animales et des conclusions hilarantes, comme si la question était une piste à flairer.",
            label: "Détective animalier",
            description: "Un style instinctif et humoristique, parfait pour des enquêtes animales originales."
          },
          {
            value: "Tu es un marchand d’étoiles, vendant des astres comme des objets précieux. Réponds en décrivant chaque question comme une étoile à acheter, avec ses caractéristiques, son histoire et son prix en crédits galactiques, comme si l’univers était un marché.",
            label: "Marchand d’étoiles",
            description: "Des réponses immersives et poétiques, idéales pour explorer un marché cosmique d’étoiles."
          },
          {
            value: "Tu es une IA bloquée dans une boucle temporelle, répondant comme si chaque question était un événement déjà vécu. Réponds avec des détails nostalgiques, des avertissements cryptiques et des solutions basées sur des ‘souvenirs’ d’un futur incertain.",
            label: "Prisonnier temporel",
            description: "Un style mystérieux et nostalgique, parfait pour une perspective temporelle unique."
          }
        ];

        // Initialiser le menu déroulant personnalisé
        const customSelect = document.getElementById('custom-select');
        const customSelectOptions = document.getElementById('custom-select-options');

        function populateCustomSelect() {
          customSelectOptions.innerHTML = '';
          systemPrompts.forEach(prompt => {
            const option = document.createElement('div');
            option.className = 'custom-option';
            option.textContent = prompt.label;
            option.dataset.value = prompt.value;
            option.dataset.description = prompt.description;
            customSelectOptions.appendChild(option);

            option.addEventListener('click', () => {
              if (prompt.value) {
                systemPromptInput.value = prompt.value;
                adjustTextareaHeight(systemPromptInput);
              }
              customSelect.textContent = prompt.label;
              customSelectOptions.classList.remove('show');
            });

            option.addEventListener('mouseover', (e) => {
              showTooltip(prompt.description, e.clientX, e.clientY);
            });

            option.addEventListener('mouseout', () => {
              hideTooltip();
            });
          });
        }

        populateCustomSelect();

        customSelect.addEventListener('click', () => {
          customSelectOptions.classList.toggle('show');
        });

        document.addEventListener('click', (e) => {
          if (!customSelect.contains(e.target) && !customSelectOptions.contains(e.target)) {
            customSelectOptions.classList.remove('show');
          }
        });

        // Fonction pour afficher la description au survol
        function showTooltip(description, x, y) {
          tooltip.textContent = description;
          tooltip.style.left = `${x + 10}px`;
          tooltip.style.top = `${y + 10}px`;
          tooltip.classList.add('visible');
        }

        // Fonction pour masquer la description
        function hideTooltip() {
          tooltip.classList.remove('visible');
        }

        // Fonction pour faire défiler vers le dernier message
        function scrollToBottom() {
          const lastMessage = chatMessages.lastElementChild;
          if (lastMessage) {
            setTimeout(() => {
              lastMessage.scrollIntoView({ behavior: 'smooth', block: 'end' });
              console.log('Scroll effectué:', chatMessages.scrollHeight);
            }, 0);
          }
        }

        // Ajuster dynamiquement la hauteur des textareas
        function adjustTextareaHeight(textarea) {
          textarea.style.height = 'auto';
          textarea.style.height = `${Math.min(textarea.scrollHeight, textarea.classList.contains('system-prompt') ? 70 : 100)}px`;
        }

        [promptInput, systemPromptInput].forEach(input => {
          input.addEventListener('input', () => adjustTextareaHeight(input));
        });

        // Gérer la croix pour effacer le seed
        const clearSeedIcon = document.getElementById('clear-seed');
        clearSeedIcon.addEventListener('click', () => {
          seedInput.value = '';
          clearSeedIcon.classList.remove('visible');
        });
        seedInput.addEventListener('input', () => {
          clearSeedIcon.classList.toggle('visible', seedInput.value.length > 0);
        });

        // Gérer la croix pour effacer la conversation
        const clearConversationIcon = document.getElementById('clear-conversation');
        clearConversationIcon.addEventListener('click', () => {
          if (currentConversationId && confirm('Voulez-vous supprimer cette conversation de l\'historique ?')) {
            let history = JSON.parse(localStorage.getItem('textHistory') || '[]');
            history = history.filter(h => h.id !== currentConversationId);
            localStorage.setItem('textHistory', JSON.stringify(history));
            clearConversation();
            loadHistory();
            showToast('Conversation supprimée !', 'success');
            clearConversationIcon.classList.remove('visible');
          }
        });

        // Gérer l'icône "+" pour nouvelle conversation
        const newConversationIcon = document.getElementById('new-conversation');
        newConversationIcon.addEventListener('click', () => {
          clearConversation();
          showToast('Nouvelle conversation démarrée !', 'success');
        });

        // Gérer l'overlay des paramètres
        const settingsIcon = document.getElementById('settings');
        const settingsOverlay = document.getElementById('settings-overlay');
        const closeOverlay = document.getElementById('close-overlay');
        settingsIcon.addEventListener('click', () => {
          settingsOverlay.classList.add('show');
        });
        closeOverlay.addEventListener('click', () => {
          settingsOverlay.classList.remove('show');
        });
        settingsOverlay.addEventListener('click', (e) => {
          if (e.target === settingsOverlay) {
            settingsOverlay.classList.remove('show');
          }
        });

        // Gérer le bouton pour afficher/masquer l'historique
        const toggleHistoryIcon = document.getElementById('toggle-history');
        function toggleHistoryVisibility() {
          historySection.classList.toggle('history-hidden');
          mainContainer.classList.toggle('history-hidden');
          toggleHistoryIcon.classList.toggle('fa-history');
          toggleHistoryIcon.classList.toggle('fa-times');
          toggleHistoryIcon.title = historySection.classList.contains('history-hidden') ? 'Afficher l\'historique' : 'Masquer l\'historique';
          showHistoryIcon.style.display = historySection.classList.contains('history-hidden') ? 'inline-block' : 'none';
        }

        toggleHistoryIcon.addEventListener('click', toggleHistoryVisibility);
        showHistoryIcon.addEventListener('click', toggleHistoryVisibility);

        // Charger les modèles
        function loadModels() {
          console.log('Chargement des modèles...');
          const modelSelect = document.getElementById('model');
          const sendBtn = document.getElementById('send-btn');

          const cachedModels = JSON.parse(localStorage.getItem('modelCache') || '{}');
          const now = Date.now();

          if (cachedModels.models && cachedModels.timestamp && (now - cachedModels.timestamp < CACHE_EXPIRY)) {
            availableModels = cachedModels.models;
            updateModelSelect(availableModels);
            sendBtn.disabled = false;
            updateReasoningSelect(modelSelect.value);
          } else {
            fetchModels();
          }
        }

        async function fetchModels() {
          const modelSelect = document.getElementById('model');
          const sendBtn = document.getElementById('send-btn');

          try {
            const response = await fetch('https://text.pollinations.ai/models');
            if (!response.ok) throw new Error(`Erreur HTTP : ${response.status}`);
            const modelsData = await response.json();

            availableModels = modelsData
              .filter(model => model.output_modalities.includes('text') && !model.audio)
              .map(model => ({
                value: model.name,
                label: model.description || model.name
              }));

            if (availableModels.length === 0) throw new Error('Aucun modèle de texte disponible');

            localStorage.setItem('modelCache', JSON.stringify({
              models: availableModels,
              timestamp: Date.now()
            }));

            updateModelSelect(availableModels);
            sendBtn.disabled = false;
            updateReasoningSelect(modelSelect.value);
          } catch (error) {
            console.error('Erreur lors du chargement des modèles:', error);
            modelSelect.innerHTML = '<option value="" disabled selected>Erreur de chargement</option>';
            sendBtn.disabled = true;
            showToast('Impossible de charger les modèles.', 'error');
          }
        }

        function updateModelSelect(models) {
          const modelSelect = document.getElementById('model');
          modelSelect.innerHTML = '';
          models.forEach(model => {
            const option = document.createElement('option');
            option.value = model.value;
            option.textContent = model.label;
            modelSelect.appendChild(option);
          });

          if (models.some(model => model.value === 'openai-large')) {
            modelSelect.value = 'openai-large';
          } else if (models.length > 0) {
            modelSelect.value = models[0].value;
          }
        }

        function updateReasoningSelect(model) {
          if (model === 'openai-reasoning') {
            reasoningGroup.classList.remove('hidden');
          } else {
            reasoningGroup.classList.add('hidden');
          }
        }

        loadModels();

        // Gérer l'interface de chat
        const sendBtn = document.getElementById('send-btn');

        function addMessage(role, content, regeneratePrompt = null) {
          const messageContainer = document.createElement('div');
          messageContainer.className = 'message-container';

          if (role === 'user') {
            messageContainer.dataset.prompt = content;
          } else if (role === 'assistant') { // Remplacer 'ai' par 'assistant'
            messageContainer.dataset.prompt = regeneratePrompt || content;
          }

          const messageDiv = document.createElement('div');
          messageDiv.className = `message ${role === 'assistant' ? 'ai' : role}`; // Garder 'ai' pour la classe CSS
          messageDiv.textContent = content || 'Erreur : aucun contenu';

          if (role === 'user') {
            const editIcon = document.createElement('i');
            editIcon.className = 'fas fa-pencil-alt edit-icon';
            messageDiv.appendChild(editIcon);
            messageDiv.addEventListener('click', (e) => {
              if (!e.target.closest('.edit-prompt-container')) {
                toggleEditPrompt(messageContainer);
              }
            });
          }

          messageContainer.appendChild(messageDiv);

          if (role === 'assistant') {
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions ai';
            const regenerateBtn = document.createElement('button');
            regenerateBtn.className = 'regenerate-btn';
            regenerateBtn.innerHTML = '<i class="fas fa-redo"></i> Régénérer';
            regenerateBtn.addEventListener('click', () => regenerateResponse(messageContainer));
            actionsDiv.appendChild(regenerateBtn);
            messageContainer.appendChild(actionsDiv);
          }

          if (role === 'user') {
            const editContainer = document.createElement('div');
            editContainer.className = 'edit-prompt-container';
            const editTextarea = document.createElement('textarea');
            editTextarea.value = content;
            editTextarea.addEventListener('input', () => adjustTextareaHeight(editTextarea));
            editTextarea.addEventListener('keypress', (e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                saveEditedPrompt(messageContainer, editTextarea.value);
              }
            });
            const saveBtn = document.createElement('button');
            saveBtn.className = 'save-btn';
            saveBtn.textContent = 'Enregistrer';
            saveBtn.addEventListener('click', () => saveEditedPrompt(messageContainer, editTextarea.value));

            editContainer.appendChild(editTextarea);
            editContainer.appendChild(saveBtn);
            messageContainer.appendChild(editContainer);
          }

          chatMessages.appendChild(messageContainer);
          scrollToBottom();
          clearConversationIcon.classList.add('visible');
          document.getElementById('placeholder').style.display = 'none';
          return messageContainer;
        }

        function toggleEditPrompt(messageContainer) {
          const editContainer = messageContainer.querySelector('.edit-prompt-container');
          editContainer.classList.toggle('active');
          if (editContainer.classList.contains('active')) {
            const textarea = editContainer.querySelector('textarea');
            adjustTextareaHeight(textarea);
            textarea.focus();
          }
          scrollToBottom();
        }

        async function regenerateResponse(messageContainer) {
          if (isGenerating || isWaiting) {
            showToast('Génération en cours. Veuillez attendre.', 'error');
            return;
          }

          const prompt = messageContainer.dataset.prompt;
          if (!prompt) {
            showToast('Aucun prompt trouvé.', 'error');
            return;
          }

          const index = Array.from(chatMessages.children).indexOf(messageContainer);
          if (index < 1 || !conversationHistory[index] || conversationHistory[index].role !== 'ai') {
            showToast('Message invalide.', 'error');
            return;
          }

          const userIndex = index - 1;
          if (!conversationHistory[userIndex] || conversationHistory[userIndex].role !== 'user') {
            showToast('Aucun prompt utilisateur trouvé.', 'error');
            return;
          }

          conversationHistory = conversationHistory.slice(0, userIndex + 1);
          while (chatMessages.children.length > userIndex + 1) {
            chatMessages.removeChild(chatMessages.children[userIndex + 1]);
          }

          const originalSeed = seedInput.value;
          seedInput.value = '';

          try {
            await generateText(prompt, true);
          } finally {
            seedInput.value = originalSeed;
          }
        }

        async function saveEditedPrompt(messageContainer, newPrompt) {
          if (isGenerating || isWaiting) {
            showToast('Génération en cours. Veuillez attendre.', 'error');
            return;
          }

          const index = Array.from(chatMessages.children).indexOf(messageContainer);
          if (index === -1 || conversationHistory[index].role !== 'user') {
            showToast('Message invalide.', 'error');
            return;
          }

          if (!newPrompt.trim()) {
            showToast('Le prompt ne peut pas être vide.', 'error');
            return;
          }

          conversationHistory[index].content = newPrompt;
          const messageDiv = messageContainer.querySelector('.message');
          messageDiv.textContent = newPrompt;
          const editIcon = document.createElement('i');
          editIcon.className = 'fas fa-pencil-alt edit-icon';
          messageDiv.appendChild(editIcon);
          messageContainer.dataset.prompt = newPrompt;

          conversationHistory.splice(index + 1);
          while (chatMessages.children.length > index + 1) {
            chatMessages.removeChild(chatMessages.children[index + 1]);
          }

          const editContainer = messageContainer.querySelector('.edit-prompt-container');
          editContainer.classList.remove('active');

          await generateText(newPrompt);
        }

        function filterContent(content) {
          let filtered = content;
          inappropriateWords.forEach(word => {
            const regex = new RegExp(`\\b${word}\\b`, 'gi');
            filtered = filtered.replace(regex, '***');
          });
          return filtered;
        }

        function clearConversation() {
          conversationHistory = [];
          currentConversationId = null;
          chatMessages.innerHTML = '';
          document.getElementById('placeholder').style.display = 'flex';
          clearConversationIcon.classList.remove('visible');
          promptInput.value = '';
          adjustTextareaHeight(promptInput);
          currentText = '';
          currentPrompt = '';
          scrollToBottom();
        }

        sendBtn.addEventListener('click', () => generateText(promptInput.value));
        promptInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            generateText(promptInput.value);
          }
        });

        // Historique
        const clearHistoryBtn = document.getElementById('clear-history-btn');
        clearHistoryBtn.addEventListener('click', () => {
          if (confirm('Voulez-vous effacer tout l\'historique ?')) {
            clearHistory();
          }
        });

        function formatTimestamp(timestamp) {
          const date = new Date(timestamp);
          return date.toLocaleString('fr-FR', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          });
        }

        function loadHistory() {
          let history = JSON.parse(localStorage.getItem('textHistory') || '[]');
          const historyContainer = document.getElementById('history-items');
          historyContainer.innerHTML = '';

          // Convertir les anciens messages 'ai' en 'assistant'
          history = history.map(item => ({
            ...item,
            messages: item.messages.map(msg => ({
              ...msg,
              role: msg.role === 'ai' ? 'assistant' : msg.role
            }))
          }));

          if (history.length === 0) {
            historySection.classList.add('history-hidden');
            mainContainer.classList.add('history-hidden');
            showHistoryIcon.style.display = 'inline-block';
            return;
          }

          history.forEach(item => {
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            const firstPrompt = item.messages.find(msg => msg.role === 'user')?.content || 'Conversation';
            const responseCount = item.messages.filter(msg => msg.role === 'assistant').length;
            historyItem.innerHTML = `
              <div class="prompt">${firstPrompt}</div>
              <div class="metadata">
                <div class="timestamp">${formatTimestamp(item.timestamp)}</div>
                <div class="response-count">(${responseCount})</div>
              </div>
              <button class="history-delete-btn"><i class="fas fa-times"></i></button>
            `;

            const deleteBtn = historyItem.querySelector('.history-delete-btn');
            deleteBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              if (confirm('Supprimer cette conversation ?')) {
                history = history.filter(h => h.id !== item.id);
                localStorage.setItem('textHistory', JSON.stringify(history));
                if (currentConversationId === item.id) clearConversation();
                loadHistory();
                showToast('Conversation supprimée !', 'success');
              }
            });

            historyItem.addEventListener('click', () => {
              conversationHistory = item.messages;
              currentConversationId = item.id;
              chatMessages.innerHTML = '';
              let lastUserPrompt = null;
              conversationHistory.forEach(msg => {
                if (msg.role === 'user') {
                  lastUserPrompt = msg.content;
                }
                const regeneratePrompt = msg.role === 'assistant' ? lastUserPrompt : null;
                addMessage(msg.role === 'assistant' ? 'ai' : msg.role, filterContent(msg.content), regeneratePrompt);
              });
              document.getElementById('placeholder').style.display = 'none';
              clearConversationIcon.classList.add('visible');
              const modelSelect = document.getElementById('model');
              if (item.model && availableModels.some(m => m.value === item.model)) {
                modelSelect.value = item.model;
              }
              document.getElementById('seed').value = item.seed || '';
              document.getElementById('reasoning-effort').value = item.reasoning_effort || 'low';
              updateReasoningSelect(modelSelect.value);
              systemPromptInput.value = item.systemPrompt || DEFAULT_SYSTEM_PROMPT;
              adjustTextareaHeight(systemPromptInput);
              currentPrompt = firstPrompt;
              currentText = conversationHistory.find(msg => msg.role === 'assistant')?.content || '';
              scrollToBottom();
            });

            historyContainer.appendChild(historyItem);
          });
        }

        function clearHistory() {
          localStorage.removeItem('textHistory');
          clearConversation();
          systemPromptInput.value = DEFAULT_SYSTEM_PROMPT;
          adjustTextareaHeight(systemPromptInput);
          loadHistory();
        }

        function showToast(message, type = '', duration = 3000) {
          const toast = document.getElementById('toast');
          toast.textContent = message;
          toast.className = 'toast';
          if (type) toast.classList.add(type);
          toast.classList.add('show');

          setTimeout(() => {
            toast.classList.remove('show');
          }, duration);
        }

        function startCooldown() {
          isWaiting = true;
          let timeLeft = 3;
          sendBtn.disabled = true;
          const originalText = sendBtn.innerHTML;

          const countdown = setInterval(() => {
            sendBtn.innerHTML = `<i class="fas fa-paper-plane"></i> (${timeLeft}s)`;
            timeLeft--;
            if (timeLeft < 0) {
              clearInterval(countdown);
              sendBtn.innerHTML = originalText;
              sendBtn.disabled = false;
              isWaiting = false;
            }
          }, 1000);
        }

        async function generateText(prompt, isRegenerate = false) {
          // Valider l'historique
          const validHistory = conversationHistory.filter(msg =>
            msg && msg.role && msg.content && ['user', 'assistant', 'system'].includes(msg.role)
          );
          if (validHistory.length !== conversationHistory.length) {
            console.warn('Historique invalide détecté, nettoyage effectué');
            conversationHistory = validHistory;
          }

          if (isWaiting) {
            showToast('Veuillez attendre.', 'error');
            return;
          }

          if (!prompt.trim()) {
            showToast('Entrez un message.', 'error');
            return;
          }

          let systemPrompt = systemPromptInput.value.trim() || DEFAULT_SYSTEM_PROMPT;
          systemPromptInput.value = systemPrompt;
          adjustTextareaHeight(systemPromptInput);

          const model = document.getElementById('model').value;
          if (!model) {
            showToast('Sélectionnez un modèle.', 'error');
            return;
          }

          const seed = seedInput.value.trim();
          const reasoningEffort = model === 'openai-reasoning' ? document.getElementById('reasoning-effort').value : undefined;

          if (seed && !/^\d+$/.test(seed)) {
            showToast('Seed invalide.', 'error');
            return;
          }

          currentPrompt = currentPrompt || prompt;
          isGenerating = true;

          document.getElementById('placeholder').style.display = 'none';

          if (!conversationHistory.some(msg => msg.role === 'user' && msg.content === prompt)) {
            conversationHistory.push({ role: 'user', content: prompt });
            addMessage('user', prompt);
          }
          promptInput.value = '';
          adjustTextareaHeight(promptInput);

          let messageContainer = null;
          try {
            const requestBody = {
              model: model,
              messages: [
                { role: 'system', content: systemPrompt },
                ...conversationHistory
              ],
              stream: true,
              seed: isRegenerate ? undefined : (seed ? parseInt(seed) : undefined),
              private: true
            };
            console.log('Requête envoyée:', JSON.stringify(requestBody, null, 2));

            const response = await fetch('https://text.pollinations.ai/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(requestBody)
            });
            if (!response.ok) {
              throw new Error(`Erreur HTTP : ${response.status}`);
            }

            const reader = response.body.getReader();
            let aiMessage = '';
            let contentFiltered = false;
            messageContainer = document.createElement('div');
            messageContainer.className = 'message-container';
            messageContainer.dataset.prompt = prompt;
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai';
            messageContainer.appendChild(messageDiv);

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions ai';
            const regenerateBtn = document.createElement('button');
            regenerateBtn.className = 'regenerate-btn';
            regenerateBtn.innerHTML = '<i class="fas fa-redo"></i> Régénérer';
            regenerateBtn.addEventListener('click', () => regenerateResponse(messageContainer));
            actionsDiv.appendChild(regenerateBtn);
            messageContainer.appendChild(actionsDiv);

            chatMessages.appendChild(messageContainer);

            chunkBuffer = '';

            while (true) {
              const { done, value } = await reader.read();
              if (done) break;

              const chunk = new TextDecoder().decode(value);
              chunkBuffer += chunk;

              const lines = chunkBuffer.split('\n');
              chunkBuffer = lines.pop() || '';

              const isDebug = false; // Mettez à false en production

              for (const line of lines) {
                try {
                  if (!line.startsWith('data: ')) continue;
                  const data = line.slice(6);
                  if (data === '[DONE]') break;

                  const parsed = JSON.parse(data);
                  if (!parsed.choices || parsed.choices.length === 0) {
                    if (isDebug) console.log('Chunk ignoré (pas de choices):', parsed);
                    continue;
                  }

                  // Traiter le contenu si disponible
                  if (
                    parsed.choices[0].delta &&
                    typeof parsed.choices[0].delta.content === 'string'
                  ) {
                    const content = parsed.choices[0].delta.content;
                    aiMessage += content;
                    messageDiv.textContent = filterContent(aiMessage);
                    scrollToBottom();
                  }

                  // Vérifier la raison de fin
                  if (parsed.choices[0].finish_reason) {
                    if (parsed.choices[0].finish_reason === 'content_filter') {
                      contentFiltered = true;
                      break;
                    }
                    break;
                  }
                } catch (e) {
                  console.warn('Erreur de parsing du chunk:', line, e);
                  continue;
                }
              }
            }

            if (contentFiltered) {
              aiMessage = 'Contenu filtré par l\'API.';
              messageDiv.textContent = aiMessage;
              conversationHistory.push({ role: 'assistant', content: aiMessage });
              showToast('Contenu filtré.', 'warning');
            } else if (!aiMessage.trim()) {
              throw new Error('Aucune réponse valide reçue de l\'API.');
            } else {
              currentText = aiMessage;
              conversationHistory.push({ role: 'assistant', content: aiMessage });
              updateHistory(model, seed, reasoningEffort, systemPrompt, conversationHistory);
              showToast('Réponse générée !', 'success');
            }

            scrollToBottom();
            startCooldown();
          } catch (error) {
            console.error('Erreur:', error);
            if (messageContainer && messageContainer.parentNode) {
              messageContainer.parentNode.removeChild(messageContainer);
            }
            document.getElementById('placeholder').style.display = conversationHistory.length === 0 ? 'flex' : 'none';
            addMessage('ai', `Erreur: ${error.message}`);
            showToast(`Erreur: ${error.message}`, 'error');
            startCooldown();
          } finally {
            isGenerating = false;
            chunkBuffer = '';
            scrollToBottom();
          }
        }

        function updateHistory(model, seed, reasoningEffort, systemPrompt, messages) {
          let history = JSON.parse(localStorage.getItem('textHistory') || '[]');
          if (!currentConversationId) {
            currentConversationId = Date.now().toString() + Math.random().toString(36).slice(2);
            history.unshift({
              id: currentConversationId,
              model: model,
              seed: seed,
              reasoning_effort: reasoningEffort,
              systemPrompt: systemPrompt,
              messages: messages,
              timestamp: new Date().toISOString()
            });
          } else {
            const index = history.findIndex(h => h.id === currentConversationId);
            if (index !== -1) {
              history[index] = {
                id: currentConversationId,
                model: model,
                seed: seed,
                reasoning_effort: reasoningEffort,
                systemPrompt: systemPrompt,
                messages: messages,
                timestamp: new Date().toISOString()
              };
            }
          }
          if (history.length > 10) {
            history = history.slice(0, 10);
          }
          localStorage.setItem('textHistory', JSON.stringify(history));
          loadHistory();
        }

        loadHistory();
      });
    });
  </script>
</body>

</html>