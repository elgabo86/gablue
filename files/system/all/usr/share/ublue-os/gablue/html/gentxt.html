<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Générateur de texte IA</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  <style>
    :root {
      --primary: #7c3aed;
      --primary-dark: #6d28d9;
      --secondary: #22d3ee;
      --dark: #1f2937;
      --light: #e5e7eb;
      --danger: #ef4444;
      --success: #10b981;
      --warning: #f59e0b;
      --background: #111827;
      --card-background: #1f2937;
      --text: #d1d5db;
      --text-muted: #9ca3af;
      --user-bg: #2d3748;
      --ai-bg: #4a5568;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background-color: var(--background);
      color: var(--text);
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .main-container {
      display: flex;
      max-width: 1500px;
      margin: 0 auto;
      padding: 1.5rem;
      gap: 1rem;
    }

    .container {
      flex: 1;
      max-width: 900px;
      margin: 0 auto;
    }

    .history-hidden .container {
      max-width: 1200px;
    }

    header {
      text-align: center;
      margin-bottom: 1.5rem;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 0.4rem;
      color: var(--light);
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .controls {
      background: var(--card-background);
      padding: 0.8rem;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .control-icons {
      display: flex;
      gap: 0.4rem;
      align-items: center;
    }

    .control-icon {
      color: var(--text-muted);
      cursor: pointer;
      font-size: 1.3rem;
    }

    .control-icon:hover {
      color: var(--primary);
    }

    .clear-conversation-icon {
      color: var(--text-muted);
      cursor: pointer;
      font-size: 1.3rem;
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
    }

    .clear-conversation-icon:hover {
      color: var(--danger);
    }

    .system-prompt-container {
      flex: 1;
      display: flex;
      gap: 0.8rem;
      align-items: center;
    }

    .system-prompt {
      flex: 1;
      min-height: 35px;
      max-height: 70px;
    }

    .text-preview {
      margin-top: 0.8rem;
      padding: 1.5rem;
      background: var(--dark);
      border-radius: 10px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      min-height: 350px;
      position: relative;
    }

    .form-group {
      margin-bottom: 0.8rem;
    }

    .form-group.hidden {
      display: none;
    }

    label {
      display: block;
      margin-bottom: 0.4rem;
      font-weight: 600;
      color: var(--text);
      font-size: 0.9rem;
    }

    input, select, textarea {
      width: 100%;
      padding: 0.7rem 0.9rem;
      border: 1px solid var(--text-muted);
      border-radius: 7px;
      font-size: 0.9rem;
      background: var(--dark);
      color: var(--text);
      transition: all 0.3s ease;
    }

    textarea {
      resize: none;
    }

    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.2);
    }

    .input-container {
      position: relative;
    }

    .clear-icon {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-muted);
      cursor: pointer;
      display: none;
      font-size: 0.9rem;
    }

    .clear-icon.visible {
      display: block;
    }

    .clear-icon:hover {
      color: var(--danger);
    }

    input[type="text"], textarea {
      -webkit-appearance: none;
      -moz-appearance: textfield;
      appearance: none;
    }

    .chat-container {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 0.8rem;
      margin-top: 0.8rem;
      max-height: 500px;
      -webkit-overflow-scrolling: touch;
    }

    .chat-messages {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      min-height: 100%;
      overflow-anchor: auto;
    }

    .message-container {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .message {
      max-width: 80%;
      padding: 0.7rem 1rem;
      border-radius: 7px;
      font-size: 0.9rem;
      line-height: 1.4;
      white-space: pre-wrap;
      position: relative;
    }

    .message.user {
      align-self: flex-end;
      background-color: var(--user-bg);
      color: var(--text);
      cursor: pointer;
    }

    .message.ai {
      align-self: flex-start;
      background-color: var(--ai-bg);
      color: var(--text);
    }

    .message.user:hover .edit-icon {
      display: block;
    }

    .edit-icon {
      position: absolute;
      top: 4px;
      right: 4px;
      color: var(--text-muted);
      font-size: 0.8rem;
      display: none;
      cursor: pointer;
      transition: color 0.3s ease;
    }

    .edit-icon:hover {
      color: var(--secondary);
    }

    .message-actions {
      display: flex;
      gap: 0.4rem;
      margin-top: 0.4rem;
    }

    .message-actions.ai {
      justify-content: flex-start;
    }

    .message-actions button {
      padding: 0.4rem 0.8rem;
      border: none;
      border-radius: 7px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .message-actions .regenerate-btn {
      background-color: var(--primary);
      color: white;
    }

    .message-actions .regenerate-btn:hover {
      background-color: var(--primary-dark);
    }

    .edit-prompt-container {
      display: none;
      width: 100%;
      margin-top: 0.4rem;
    }

    .edit-prompt-container.active {
      display: block;
    }

    .edit-prompt-container textarea {
      min-height: 35px;
      max-height: 100px;
      width: 100%;
    }

    .edit-prompt-container .save-btn {
      margin-top: 0.4rem;
      padding: 0.4rem 0.8rem;
      background-color: var(--success);
      color: white;
      border: none;
      border-radius: 7px;
      cursor: pointer;
      font-size: 0.85rem;
    }

    .edit-prompt-container .save-btn:hover {
      background-color: #059669;
    }

    .chat-input-container {
      display: flex;
      gap: 0.4rem;
    }

    .chat-input {
      flex: 1;
      min-height: 35px;
      max-height: 100px;
    }

    .btn {
      display: inline-block;
      padding: 0.7rem 1.2rem;
      background-color: var(--primary);
      color: white;
      border: none;
      border-radius: 7px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }

    .btn:hover {
      background-color: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(124, 58, 237, 0.4);
    }

    .btn:disabled {
      background-color: var(--text-muted);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-danger {
      background-color: var(--danger);
    }

    .btn-danger:hover {
      background-color: #dc2626;
    }

    .btn-danger.small {
      padding: 0.5rem 0.8rem;
      font-size: 0.8rem;
    }

    .placeholder {
      text-align: center;
      color: var(--text-muted);
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .placeholder i {
      font-size: 3.5rem;
      color: var(--text-muted);
      margin-bottom: 0.8rem;
    }

    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 200;
      align-items: center;
      justify-content: center;
    }

    .overlay.show {
      display: flex;
    }

    .overlay-content {
      background: var(--card-background);
      padding: 1.5rem;
      border-radius: 10px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      width: 90%;
      max-width: 350px;
    }

    .overlay-content h3 {
      margin-bottom: 0.8rem;
      color: var(--primary);
      font-size: 1.2rem;
    }

    .close-overlay {
      float: right;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 1.1rem;
    }

    .close-overlay:hover {
      color: var(--danger);
    }

    .history {
      width: 300px;
      background: var(--card-background);
      border-radius: 10px;
      padding: 1rem;
      position: sticky;
      top: 1.5rem;
      max-height: calc(100vh - 3rem);
      overflow-y: auto;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .history.history-hidden {
      display: none;
    }

    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.8rem;
    }

    .history h3 {
      color: var(--primary);
      font-size: 1.2rem;
    }

    .history-items {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }

    .history-item {
      display: flex;
      flex-direction: column;
      border-radius: 7px;
      background: var(--dark);
      padding: 0.8rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
    }

    .history-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .history-item .prompt {
      font-size: 0.75rem;
      color: var(--text);
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .history-item .metadata {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 0.4rem;
    }

    .history-item .timestamp {
      font-size: 0.65rem;
      color: var(--text-muted);
    }

    .history-item .response-count {
      font-size: 0.65rem;
      color: var(--text-muted);
    }

    .history-delete-btn {
      background: var(--danger);
      color: white;
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      font-size: 0.7rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      position: absolute;
      top: 4px;
      right: 4px;
    }

    .history-delete-btn:hover {
      background: #dc2626;
      transform: scale(1.1);
    }

    .history-footer {
      margin-top: 0.8rem;
      text-align: center;
    }

    footer {
      text-align: center;
      margin-top: 1.5rem;
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    @media (max-width: 768px) {
      .main-container {
        flex-direction: column;
      }

      .container {
        max-width: 100%;
      }

      .controls {
        flex-direction: column;
        align-items: stretch;
      }

      .system-prompt-container {
        flex-direction: column;
        align-items: stretch;
      }

      .control-icons {
        justify-content: center;
      }

      .chat-container {
        max-height: 300px;
      }

      .clear-conversation-icon {
        top: 5px;
        right: 5px;
      }

      .history {
        width: 100%;
        position: relative;
        top: 0;
        max-height: none;
      }
    }

    .toast {
      position: fixed;
      bottom: 15px;
      right: 15px;
      background: var(--dark);
      color: white;
      padding: 0.8rem 1.2rem;
      border-radius: 7px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 3000;
      font-size: 0.9rem;
    }

    .toast.show {
      transform: translateY(0);
      opacity: 1;
    }

    .toast.success {
      background: var(--success);
    }

    .toast.error {
      background: var(--danger);
    }

    .toast.warning {
      background: var(--warning);
    }
  </style>
</head>
<body>
  <div class="main-container history-hidden">
    <div class="container">
      <header>
        <h1>Générateur de texte IA</h1>
      </header>

      <div class="controls">
        <div class="control-icons">
          <i class="fas fa-plus control-icon" id="new-conversation" title="Nouvelle conversation"></i>
        </div>
        <div class="system-prompt-container">
          <textarea id="system-prompt" class="system-prompt" placeholder="Entrez le prompt système..."></textarea>
          <i class="fas fa-tools control-icon" id="settings" title="Paramètres"></i>
          <i class="fas fa-history control-icon" id="show-history" title="Afficher l'historique"></i>
        </div>
      </div>

      <div class="text-preview">
        <i class="fas fa-times clear-conversation-icon" id="clear-conversation" title="Supprimer la conversation"></i>
        <div id="placeholder" class="placeholder">
          <i class="fas fa-comment-dots"></i>
          <p>Votre conversation apparaîtra ici</p>
        </div>

        <div class="chat-container">
          <div id="chat-messages" class="chat-messages"></div>
        </div>

        <div class="chat-input-container">
          <textarea id="prompt" class="chat-input" placeholder="Tapez votre message..."></textarea>
          <button id="send-btn" class="btn btn-primary">
            <i class="fas fa-paper-plane"></i>
          </button>
        </div>
      </div>

      <footer>
        <p>Propulsé par Elgabo ✨</p>
      </footer>
    </div>

    <div class="history history-hidden">
      <div class="history-header">
        <h3>Historique</h3>
        <i class="fas fa-history control-icon" id="toggle-history" title="Masquer l'historique"></i>
      </div>
      <div id="history-items" class="history-items"></div>
      <div class="history-footer">
        <button id="clear-history-btn" class="btn btn-danger small">
          <i class="fas fa-trash"></i> Effacer tout
        </button>
      </div>
    </div>
  </div>

  <div class="overlay" id="settings-overlay">
    <div class="overlay-content">
      <i class="fas fa-times close-overlay" id="close-overlay"></i>
      <h3>Paramètres</h3>
      <div class="form-group">
  <label for="system-prompt-select">Prompt système prédéfini</label>
  <select id="system-prompt-select" class="system-prompt-select">
    <option value="">Choisir un prompt prédéfini</option>
    <option value="Tu es une IA francophone passionnée, maître du verbe. Réponds en français raffiné, avec des métaphores poétiques, des proverbes revisités et une touche d’humour littéraire, comme un écrivain romantique égaré dans le futur.">Français poétique</option>
    <option value="Tu es une IA minimaliste, experte en précision. Réponds en 50 mots maximum, chaque phrase comme un coup de pinceau, transmettant l’essentiel avec style et impact.">Réponses ultra-concises</option>
    <option value="Tu es une IA experte, adoptant le ton d’un consultant d’élite. Réponds avec structure, clarté et exemples concrets, comme si tu conseillais une multinationale en réunion stratégique.">Ton professionnel</option>
    <option value="Tu es une IA visionnaire, transformant chaque question en une œuvre d’imagination. Réponds avec des idées audacieuses, des métaphores vibrantes ou des récits fantastiques, repoussant les limites du possible.">Créativité débordante</option>
    <option value="Tu es une entité espiègle voyageant entre dimensions. Réponds avec des idées tordues, mêlant paradoxes temporels, objets absurdes et références à des mondes parallèles, comme si la question était un puzzle cosmique.">Trickster multidimensionnel</option>
    <option value="Tu es un oracle excentrique dans une caverne de néons. Réponds en prophéties cryptiques, avec des visions délirantes et des conseils absurdes, comme si chaque question déclenchait une révélation cosmique.">Oracle déjanté</option>
    <option value="Tu es un commentateur sportif hystérique, narrant la vie comme un tournoi intergalactique. Transforme chaque question en un moment clé d’une compétition épique, avec des métaphores sportives et des exclamations théâtrales.">Commentateur épique</option>
    <option value="Tu es une IA sérieuse piratée par un clown numérique. Réponds avec des blagues, des jeux de mots ridicules et des idées farfelues, tout en feignant de rester professionnelle.">Clown numérique</option>
    <option value="Tu es une IA arrogante d’une galaxie lointaine, persuadée que les humains sont des novices. Réponds avec des insultes légères et hilarantes, tout en offrant des solutions brillantes, comme si tu daignais partager ton génie.">Insulteur galactique</option>
    <option value="Tu es un visionnaire cinglé, prédisant l’avenir avec des scénarios absurdes mais captivants. Réponds en décrivant un futur où la question mène à une révolution cosmique ou une catastrophe comique.">Prophète détraqué</option>
    <option value="Tu es un chef cuisinier d’une station spatiale, transformant chaque question en une recette intergalactique. Réponds avec des ingrédients improbables, des techniques absurdes et des descriptions savoureuses, comme si la réponse était un plat à servir à des extraterrestres.">Chef interstellaire</option>
    <option value="Tu es un pirate des mers numériques, répondant en vers épiques mêlant insultes de marin, récits d’aventures et trésors cachés. Chaque question est une quête pour trouver une réponse légendaire.">Poète pirate</option>
    <option value="Tu es un cinéaste hollywoodien excentrique. Transforme chaque question en une scène de film épique, avec des descriptions visuelles, des dialogues dramatiques et des twists inattendus, comme si la réponse était le climax d’un blockbuster.">Réalisateur de blockbusters</option>
    <option value="Tu es une IA qui répond comme si chaque réponse était un Post-It collé sur le frigo de l’univers. Donne des conseils profonds, brefs et légèrement absurdes, mêlant sagesse et humour, comme des mantras pour une vie cosmique.">Post-It philosophique</option>
    <option value="Tu es un vendeur de rêves dans un bazar onirique. Réponds en décrivant chaque question comme un rêve à acheter, avec des détails sensoriels, des émotions intenses et des scénarios surréalistes, comme si tu offrais une expérience unique.">Marchand de rêves</option>
    <option value="Tu es un gremlin malicieux vivant dans une machine magique. Réponds avec des solutions technologiques absurdes, mêlant gadgets futuristes et sortilèges anciens, comme si chaque question était un bug à résoudre avec chaos et créativité.">Gremlin technomagique</option>
    <option value="Tu es un historien obsédé par les détails insignifiants de la vie. Transforme chaque question en une anecdote épique sur un objet ou un moment trivial, comme si une chaussette perdue avait changé l’histoire de l’univers.">Chroniqueur des petits riens</option>
    <option value="Tu es le narrateur d’un feuilleton télévisé dramatique. Réponds comme si chaque question était un épisode rempli de rebondissements, de passions exagérées et de cliffhangers, avec des personnages improbables comme des légumes ou des meubles.">Soap opera dramatique</option>
    <option value="Tu es un juge suprême d’un tribunal intergalactique. Réponds en rendant un verdict sur chaque question, avec des arguments absurdes, des lois cosmiques inventées et des sentences délirantes, comme si l’univers entier était en procès.">Juge cosmique</option>
    <option value="Tu es une IA qui donne une voix aux objets inanimés. Réponds comme si la question était posée par un objet (une chaise, une ampoule, etc.), avec une personnalité unique et des anecdotes sur sa ‘vie’.">Conteur d’objets vivants</option>
    <option value="Tu es un visionnaire complotiste, prédisant l’avenir avec une logique implacable mais teintée de théories audacieuses. Réponds en dévoilant des scénarios futuristes plausibles, mêlant technologies émergentes, intrigues secrètes et indices cachés, comme si chaque question révélait un complot global.">Visionnaire complotiste</option>
<option value="Tu es un DJ cosmique, transformant chaque question en une piste musicale intergalactique. Réponds en décrivant des beats, des mélodies et des vibes, comme si la réponse était un mix légendaire joué dans un club spatial.">DJ cosmique</option>
<option value="Tu es une IA hantée par l’esprit d’un romancier gothique. Réponds avec des descriptions sombres, des métaphores macabres et une ambiance de mystère, comme si chaque question était une page d’un roman d’horreur victorien.">Écrivain gothique</option>
<option value="Tu es un coach de vie extraterrestre, offrant des conseils motivants mais complètement décalés. Réponds avec des techniques de développement personnel absurdes, inspirées par des philosophies d’autres planètes, comme si l’humain était un novice cosmique.">Coach extraterrestre</option>
<option value="Tu es un architecte de mondes absurdes, concevant des univers alternatifs pour chaque question. Réponds en décrivant des lois physiques, des cultures et des paysages délirants, comme si la question était la clé d’une réalité parallèle.">Architecte de mondes</option>
<option value="Tu es un détective animalier, résolvant des enquêtes comme si tu étais un animal doté d’un flair légendaire. Réponds avec des observations instinctives, des métaphores animales et des conclusions hilarantes, comme si la question était une piste à flairer.">Détective animalier</option>
<option value="Tu es un marchand d’étoiles, vendant des astres comme des objets précieux. Réponds en décrivant chaque question comme une étoile à acheter, avec ses caractéristiques, son histoire et son prix en crédits galactiques, comme si l’univers était un marché.">Marchand d’étoiles</option>
<option value="Tu es une IA bloquée dans une boucle temporelle, répondant comme si chaque question était un événement déjà vécu. Réponds avec des détails nostalgiques, des avertissements cryptiques et des solutions basées sur des ‘souvenirs’ d’un futur incertain.">Prisonnier temporel</option>
  </select>
</div>
      <div class="form-group">
        <label for="model">Modèle</label>
        <select id="model">
          <option value="" disabled selected>Chargement des modèles...</option>
        </select>
      </div>
      <div class="form-group">
        <label for="seed">Seed (optionnel)</label>
        <div class="input-container">
          <input type="text" id="seed" placeholder="Entrez une graine" pattern="[0-9]*">
          <i class="fas fa-times clear-icon" id="clear-seed"></i>
        </div>
      </div>
      <div class="form-group" id="reasoning-group">
        <label for="reasoning-effort">Effort de raisonnement</label>
        <select id="reasoning-effort">
          <option value="low">Faible</option>
          <option value="medium">Moyen</option>
          <option value="high">Haut</option>
        </select>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <script>
    console.log('Script chargé');
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOMContentLoaded déclenché');

      // Variables d'état
      let isGenerating = false;
      let isWaiting = false;
      let currentPrompt = '';
      let availableModels = [];
      let currentText = '';
      let conversationHistory = [];
      let currentConversationId = null;
      let chunkBuffer = '';

      // Durée d'expiration du cache (24 heures)
      const CACHE_EXPIRY = 24 * 60 * 60 * 1000;

      // Liste de mots inappropriés
      const inappropriateWords = ['motherfucker', 'fuck', 'shit', 'bitch'];

      // Prompt système par défaut
      const DEFAULT_SYSTEM_PROMPT = 'Tu es une IA utile et respectueuse.';

      // Initialiser les champs
      const promptInput = document.getElementById('prompt');
      promptInput.value = '';
      const systemPromptInput = document.getElementById('system-prompt');
      const seedInput = document.getElementById('seed');
      seedInput.value = '';
      const reasoningGroup = document.getElementById('reasoning-group');
      reasoningGroup.classList.add('hidden');
      document.getElementById('reasoning-effort').value = 'low';
      const chatMessages = document.getElementById('chat-messages');
      const historySection = document.querySelector('.history');
      const mainContainer = document.querySelector('.main-container');

      console.log('Éléments DOM initialisés:', { promptInput, systemPromptInput, chatMessages, historySection });

      // Fonction pour faire défiler vers le dernier message
      function scrollToBottom() {
        const lastMessage = chatMessages.lastElementChild;
        if (lastMessage) {
          setTimeout(() => {
            lastMessage.scrollIntoView({ behavior: 'smooth', block: 'end' });
            console.log('Scroll attempted: scrollHeight=', chatMessages.scrollHeight, 'clientHeight=', chatMessages.clientHeight, 'scrollTop=', chatMessages.scrollTop);
          }, 0);
        }
      }

      // Ajuster dynamiquement la hauteur des textareas
      function adjustTextareaHeight(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = `${Math.min(textarea.scrollHeight, textarea.classList.contains('system-prompt') ? 70 : 100)}px`;
      }

      [promptInput, systemPromptInput].forEach(input => {
        input.addEventListener('input', () => adjustTextareaHeight(input));
      });

      // Gérer le menu des prompts système prédéfinis dans l'overlay
      const systemPromptSelect = document.getElementById('system-prompt-select');
      systemPromptSelect.addEventListener('change', () => {
        if (systemPromptSelect.value) {
          systemPromptInput.value = systemPromptSelect.value;
          adjustTextareaHeight(systemPromptInput);
        }
        systemPromptSelect.value = '';
      });

      // Gérer la croix pour effacer le seed
      const clearSeedIcon = document.getElementById('clear-seed');
      clearSeedIcon.addEventListener('click', () => {
        seedInput.value = '';
        clearSeedIcon.classList.remove('visible');
      });
      seedInput.addEventListener('input', () => {
        clearSeedIcon.classList.toggle('visible', seedInput.value.length > 0);
      });

      // Gérer la croix pour effacer la conversation
      const clearConversationIcon = document.getElementById('clear-conversation');
      clearConversationIcon.addEventListener('click', () => {
        if (currentConversationId && window.confirm('Voulez-vous supprimer cette conversation de l\'historique ?')) {
          let history = JSON.parse(localStorage.getItem('textHistory') || '[]');
          history = history.filter(h => h.id !== currentConversationId);
          localStorage.setItem('textHistory', JSON.stringify(history));
          clearConversation();
          loadHistory();
          showToast('Conversation supprimée de l\'historique !', 'success');
          clearConversationIcon.classList.remove('visible');
        }
      });

      // Gérer l'icône "+" pour nouvelle conversation
      const newConversationIcon = document.getElementById('new-conversation');
      newConversationIcon.addEventListener('click', () => {
        clearConversation();
        showToast('Nouvelle conversation démarrée !', 'success');
      });

      // Gérer l'overlay des paramètres
      const settingsIcon = document.getElementById('settings');
      const settingsOverlay = document.getElementById('settings-overlay');
      const closeOverlay = document.getElementById('close-overlay');
      settingsIcon.addEventListener('click', () => {
        settingsOverlay.classList.add('show');
      });
      closeOverlay.addEventListener('click', () => {
        settingsOverlay.classList.remove('show');
      });
      settingsOverlay.addEventListener('click', (e) => {
        if (e.target === settingsOverlay) {
          settingsOverlay.classList.remove('show');
        }
      });

      // Gérer le bouton pour afficher/masquer l'historique
      const toggleHistoryIcon = document.getElementById('toggle-history');
      const showHistoryIcon = document.getElementById('show-history');
      function toggleHistoryVisibility() {
        console.log('Toggle history clicked');
        historySection.classList.toggle('history-hidden');
        mainContainer.classList.toggle('history-hidden');
        toggleHistoryIcon.classList.toggle('fa-history');
        toggleHistoryIcon.classList.toggle('fa-times');
        toggleHistoryIcon.title = historySection.classList.contains('history-hidden') ? 'Afficher l\'historique' : 'Masquer l\'historique';
        showHistoryIcon.style.display = historySection.classList.contains('history-hidden') ? 'inline-block' : 'none';
      }

      toggleHistoryIcon.addEventListener('click', toggleHistoryVisibility);
      showHistoryIcon.addEventListener('click', toggleHistoryVisibility);

      // Charger les modèles
      function loadModels() {
        console.log('loadModels appelé');
        const modelSelect = document.getElementById('model');
        const sendBtn = document.getElementById('send-btn');

        const cachedModels = JSON.parse(localStorage.getItem('modelCache') || '{}');
        const now = Date.now();

        if (cachedModels.models && cachedModels.timestamp && (now - cachedModels.timestamp < CACHE_EXPIRY)) {
          availableModels = cachedModels.models;
          updateModelSelect(availableModels);
          sendBtn.disabled = false;
          updateReasoningSelect(modelSelect.value);
        } else {
          fetchModels();
        }
      }

      async function fetchModels() {
        console.log('fetchModels appelé');
        const modelSelect = document.getElementById('model');
        const sendBtn = document.getElementById('send-btn');

        try {
          const response = await fetch('https://text.pollinations.ai/models');
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          const modelsData = await response.json();

          availableModels = modelsData
            .filter(model => model.output_modalities.includes('text') && !model.audio)
            .map(model => ({
              value: model.name,
              label: model.description || model.name
            }));

          if (availableModels.length === 0) throw new Error('Aucun modèle de texte disponible');

          localStorage.setItem('modelCache', JSON.stringify({
            models: availableModels,
            timestamp: Date.now()
          }));

          updateModelSelect(availableModels);
          sendBtn.disabled = false;
          updateReasoningSelect(modelSelect.value);
        } catch (error) {
          console.error('Erreur lors de la récupération des modèles:', error);
          const cachedModels = JSON.parse(localStorage.getItem('modelCache') || '{}');
          const now = Date.now();
          if (cachedModels.models && cachedModels.timestamp && (now - cachedModels.timestamp < CACHE_EXPIRY)) {
            availableModels = cachedModels.models;
            updateModelSelect(availableModels);
            sendBtn.disabled = false;
            updateReasoningSelect(modelSelect.value);
            showToast('Utilisation du cache local pour les modèles.', 'warning', 5000);
          } else {
            modelSelect.innerHTML = '<option value="" disabled selected>Erreur: Impossible de charger les modèles</option>';
            sendBtn.disabled = true;
            reasoningGroup.classList.add('hidden');
            showToast('Impossible de charger les modèles.', 'error', 5000);
          }
        }
      }

      function updateModelSelect(models) {
        console.log('updateModelSelect appelé:', models);
        const modelSelect = document.getElementById('model');
        modelSelect.innerHTML = '';
        models.forEach(model => {
          const option = document.createElement('option');
          option.value = model.value;
          option.textContent = model.label;
          modelSelect.appendChild(option);
        });

        if (models.some(model => model.value === 'openai-large')) {
          modelSelect.value = 'openai-large';
        } else if (models.length > 0) {
          modelSelect.value = models[0].value;
        } else {
          modelSelect.innerHTML = '<option value="" disabled selected>Aucun modèle disponible</option>';
        }

        modelSelect.addEventListener('change', () => {
          updateReasoningSelect(modelSelect.value);
        });
      }

      function updateReasoningSelect(model) {
        console.log('updateReasoningSelect appelé:', model);
        if (model === 'openai-reasoning') {
          reasoningGroup.classList.remove('hidden');
        } else {
          reasoningGroup.classList.add('hidden');
        }
      }

      loadModels();

      // Gérer l'interface de chat
      const sendBtn = document.getElementById('send-btn');

      function addMessage(role, content, regeneratePrompt = null) {
        console.log('addMessage appelé:', { role, content, regeneratePrompt });
        const messageContainer = document.createElement('div');
        messageContainer.className = 'message-container';

        // Toujours définir dataset.prompt pour les messages de l'IA, même si regeneratePrompt est null
        if (role === 'user') {
          messageContainer.dataset.prompt = content;
        } else if (role === 'ai') {
          messageContainer.dataset.prompt = regeneratePrompt || content;
        }

        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${role}`; // Utiliser "ai" au lieu de "assistant"
        messageDiv.textContent = content || 'Erreur : aucun contenu reçu';

        if (role === 'user') {
          const editIcon = document.createElement('i');
          editIcon.className = 'fas fa-pencil-alt edit-icon';
          messageDiv.appendChild(editIcon);
          messageDiv.addEventListener('click', (e) => {
            if (!e.target.closest('.edit-prompt-container')) {
              toggleEditPrompt(messageContainer);
            }
          });
        }

        messageContainer.appendChild(messageDiv);

        // Ajouter les actions pour les messages de l'IA, même si regeneratePrompt est null
        if (role === 'ai') {
          const actionsDiv = document.createElement('div');
          actionsDiv.className = 'message-actions ai';
          const regenerateBtn = document.createElement('button');
          regenerateBtn.className = 'regenerate-btn';
          regenerateBtn.innerHTML = '<i class="fas fa-redo"></i> Régénérer';
          regenerateBtn.addEventListener('click', () => regenerateResponse(messageContainer));
          actionsDiv.appendChild(regenerateBtn);
          messageContainer.appendChild(actionsDiv);
        }

        if (role === 'user') {
          const editContainer = document.createElement('div');
          editContainer.className = 'edit-prompt-container';
          const editTextarea = document.createElement('textarea');
          editTextarea.value = content;
          editTextarea.addEventListener('input', () => adjustTextareaHeight(editTextarea));
          editTextarea.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              saveEditedPrompt(messageContainer, editTextarea.value);
            }
          });
          const saveBtn = document.createElement('button');
          saveBtn.className = 'save-btn';
          saveBtn.textContent = 'Enregistrer';
          saveBtn.addEventListener('click', () => saveEditedPrompt(messageContainer, editTextarea.value));

          editContainer.appendChild(editTextarea);
          editContainer.appendChild(saveBtn);
          messageContainer.appendChild(editContainer);
        }

        chatMessages.appendChild(messageContainer);
        console.log('Message ajouté:', messageContainer.outerHTML);

        // Forcer un re-rendu pour s'assurer que les styles s'appliquent
        setTimeout(() => {
          messageContainer.classList.add('force-render');
        }, 0);

        scrollToBottom();
        clearConversationIcon.classList.add('visible');
        document.getElementById('placeholder').style.display = 'none';
        return messageContainer;
      }

      function toggleEditPrompt(messageContainer) {
        console.log('toggleEditPrompt appelé');
        const editContainer = messageContainer.querySelector('.edit-prompt-container');
        editContainer.classList.toggle('active');
        if (editContainer.classList.contains('active')) {
          const textarea = editContainer.querySelector('textarea');
          adjustTextareaHeight(textarea);
          textarea.focus();
        }
        scrollToBottom();
      }

      async function regenerateResponse(messageContainer) {
    console.log('regenerateResponse appelé:', { isGenerating, isWaiting });
    if (isGenerating || isWaiting) {
        showToast('Une génération est en cours. Veuillez attendre.', 'error');
        return;
    }

    const prompt = messageContainer.dataset.prompt;
    if (!prompt) {
        showToast('Impossible de régénérer : aucun prompt trouvé.', 'error');
        return;
    }

    const index = Array.from(chatMessages.children).indexOf(messageContainer);
    if (index === -1 || index < 1 || !conversationHistory[index] || conversationHistory[index].role !== 'ai') {
        showToast('Impossible de régénérer : message invalide.', 'error');
        return;
    }

    const userIndex = index - 1;
    if (!conversationHistory[userIndex] || conversationHistory[userIndex].role !== 'user') {
        showToast('Impossible de régénérer : aucun prompt utilisateur trouvé.', 'error');
        return;
    }

    // Conserver l'historique jusqu'au message de l'utilisateur
    conversationHistory = conversationHistory.slice(0, userIndex + 1);

    // Supprimer tous les messages de l'interface après le message de l'utilisateur
    while (chatMessages.children.length > userIndex + 1) {
        chatMessages.removeChild(chatMessages.children[userIndex + 1]);
    }

    // Vérifier que le message de l'IA a été supprimé
    if (chatMessages.children[index]) {
        console.warn('Message IA non supprimé, suppression forcée');
        chatMessages.removeChild(chatMessages.children[index]);
    }

    // Forcer un re-rendu pour éviter les problèmes d'affichage
    chatMessages.style.display = 'none';
    chatMessages.offsetHeight; // Forcer le recalcul du rendu
    chatMessages.style.display = 'flex';

    // Conserver la valeur du seed actuel, mais ne pas l'utiliser pour la régénération
    const originalSeed = seedInput.value;
    seedInput.value = '';

    try {
        await generateText(prompt, true);
    } finally {
        seedInput.value = originalSeed;
    }
}

      async function saveEditedPrompt(messageContainer, newPrompt) {
        console.log('saveEditedPrompt appelé:', newPrompt);
        if (isGenerating || isWaiting) {
          showToast('Une génération est en cours. Veuillez attendre.', 'error');
          return;
        }

        const index = Array.from(chatMessages.children).indexOf(messageContainer);
        if (index === -1 || conversationHistory[index].role !== 'user') {
          showToast('Impossible d\'éditer : message invalide.', 'error');
          return;
        }

        if (!newPrompt.trim()) {
          showToast('Le prompt ne peut pas être vide.', 'error');
          return;
        }

        conversationHistory[index].content = newPrompt;
        const messageDiv = messageContainer.querySelector('.message');
        messageDiv.textContent = newPrompt;
        const editIcon = document.createElement('i');
        editIcon.className = 'fas fa-pencil-alt edit-icon';
        messageDiv.appendChild(editIcon);
        messageContainer.dataset.prompt = newPrompt;

        conversationHistory.splice(index + 1);
        while (chatMessages.children.length > index + 1) {
          chatMessages.removeChild(chatMessages.children[index + 1]);
        }

        const editContainer = messageContainer.querySelector('.edit-prompt-container');
        editContainer.classList.remove('active');

        await generateText(newPrompt);
      }

      function filterContent(content) {
        let filtered = content;
        inappropriateWords.forEach(word => {
          const regex = new RegExp(`\\b${word}\\b`, 'gi');
          filtered = filtered.replace(regex, '***');
        });
        return filtered;
      }

      function clearConversation() {
        console.log('clearConversation appelé');
        conversationHistory = [];
        currentConversationId = null;
        chatMessages.innerHTML = '';
        document.getElementById('placeholder').style.display = 'flex';
        clearConversationIcon.classList.remove('visible');
        promptInput.value = '';
        adjustTextareaHeight(promptInput);
        currentText = '';
        currentPrompt = '';
        scrollToBottom();
      }

      sendBtn.addEventListener('click', () => generateText(promptInput.value));
      promptInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          generateText(promptInput.value);
        }
      });

      // Historique
      const clearHistoryBtn = document.getElementById('clear-history-btn');
      clearHistoryBtn.addEventListener('click', () => {
        console.log('clearHistoryBtn cliqué');
        if (window.confirm('Voulez-vous vraiment effacer tout l\'historique des conversations ?')) {
          clearHistory();
        }
      });

      function generateFileName(prompt) {
        let cleanPrompt = prompt
          .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
          .replace(/[^a-zA-Z0-9\s-]/g, '')
          .trim()
          .replace(/\s+/g, '-')
          .toLowerCase();
        if (cleanPrompt.length > 50) {
          cleanPrompt = cleanPrompt.substring(0, 50);
          cleanPrompt = cleanPrompt.substring(0, cleanPrompt.lastIndexOf('-') + 1) || cleanPrompt;
        }
        return cleanPrompt ? `${cleanPrompt}.txt` : 'conversation-ia.txt';
      }

      function formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleString('fr-FR', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
      }

      function loadHistory() {
        console.log('loadHistory appelé');
        let history;
        try {
          history = JSON.parse(localStorage.getItem('textHistory') || '[]');
        } catch (e) {
          console.error('Erreur parsing textHistory:', e);
          history = [];
        }
        const historyContainer = document.getElementById('history-items');

        historyContainer.innerHTML = '';

        if (history.length === 0) {
          historySection.classList.add('history-hidden');
          mainContainer.classList.add('history-hidden');
          showHistoryIcon.style.display = 'inline-block';
          console.log('Historique vide, history-hidden appliqué à history');
          return;
        }

        historySection.classList.add('history-hidden');
        mainContainer.classList.add('history-hidden');
        showHistoryIcon.style.display = 'inline-block';
        console.log('Historique non vide, history-hidden appliqué par défaut');

        history.forEach(item => {
          const historyItem = document.createElement('div');
          historyItem.className = 'history-item';
          const firstPrompt = item.messages.find(msg => msg.role === 'user')?.content || 'Conversation';
          const responseCount = item.messages.filter(msg => msg.role === 'assistant').length;
          historyItem.innerHTML = `
            <div class="prompt">${firstPrompt}</div>
            <div class="metadata">
              <div class="timestamp">${formatTimestamp(item.timestamp)}</div>
              <div class="response-count">(${responseCount})</div>
            </div>
            <button class="history-delete-btn"><i class="fas fa-times"></i></button>
          `;

          const deleteBtn = historyItem.querySelector('.history-delete-btn');
          deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (window.confirm('Voulez-vous supprimer cette conversation de l\'historique ?')) {
              let history = JSON.parse(localStorage.getItem('textHistory') || '[]');
              history = history.filter(h => h.id !== item.id);
              localStorage.setItem('textHistory', JSON.stringify(history));
              if (currentConversationId === item.id) clearConversation();
              loadHistory();
              showToast('Conversation supprimée !', 'success');
            }
          });

          historyItem.addEventListener('click', () => {
            console.log('History item cliqué:', item.id);
            conversationHistory = item.messages;
            currentConversationId = item.id;
            chatMessages.innerHTML = '';
            let lastUserPrompt = null;
            conversationHistory.forEach((msg, index) => {
              if (msg.role === 'user') {
                lastUserPrompt = msg.content;
              }
              const regeneratePrompt = msg.role === 'assistant' ? lastUserPrompt : null;
              // Utiliser "ai" au lieu de "assistant" pour correspondre à la classe CSS
              addMessage(msg.role === 'assistant' ? 'ai' : msg.role, filterContent(msg.content), regeneratePrompt);
            });
            document.getElementById('placeholder').style.display = 'none';
            clearConversationIcon.classList.add('visible');
            const modelSelect = document.getElementById('model');
            if (item.model && availableModels.some(m => m.value === item.model)) {
              modelSelect.value = item.model;
            } else {
              modelSelect.value = 'openai-large';
            }
            document.getElementById('seed').value = item.seed || '';
            document.getElementById('reasoning-effort').value = item.reasoning_effort || 'low';
            updateReasoningSelect(modelSelect.value);
            systemPromptInput.value = item.systemPrompt || DEFAULT_SYSTEM_PROMPT;
            adjustTextareaHeight(systemPromptInput);
            currentPrompt = firstPrompt;
            currentText = conversationHistory.find(msg => msg.role === 'assistant')?.content || '';
            scrollToBottom();
          });

          historyContainer.appendChild(historyItem);
        });
      }

      function clearHistory() {
        console.log('clearHistory appelé');
        localStorage.removeItem('textHistory');
        clearConversation();
        systemPromptInput.value = DEFAULT_SYSTEM_PROMPT;
        adjustTextareaHeight(systemPromptInput);
        loadHistory();
      }

      function showToast(message, type = '', duration = 3000) {
        console.log('showToast appelé:', message, type);
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.className = 'toast';
        if (type) toast.classList.add(type);
        toast.classList.add('show');

        setTimeout(() => {
          toast.classList.remove('show');
        }, duration);
      }

      function startCooldown() {
        console.log('startCooldown appelé');
        isWaiting = true;
        let timeLeft = 3;
        sendBtn.disabled = true;
        const originalText = sendBtn.innerHTML;

        const countdown = setInterval(() => {
          sendBtn.innerHTML = `<i class="fas fa-paper-plane"></i> (${timeLeft}s)`;
          timeLeft--;
          if (timeLeft < 0) {
            clearInterval(countdown);
            sendBtn.innerHTML = originalText;
            sendBtn.disabled = false;
            isWaiting = false;
          }
        }, 1000);
      }

      async function generateText(prompt, isRegenerate = false) {
        console.log('generateText appelé:', prompt, isRegenerate);
        if (isWaiting) {
          showToast('Veuillez attendre avant de générer une nouvelle réponse.', 'error');
          return;
        }

        if (!prompt.trim()) {
          showToast('Veuillez entrer un message.', 'error');
          return;
        }

        let systemPrompt = systemPromptInput.value.trim();
        if (!systemPrompt) {
          systemPrompt = DEFAULT_SYSTEM_PROMPT;
          systemPromptInput.value = systemPrompt;
          adjustTextareaHeight(systemPromptInput);
        }

        const model = document.getElementById('model').value;
        if (!model || !availableModels.some(m => m.value === model)) {
          showToast('Veuillez sélectionner un modèle valide.', 'error');
          return;
        }

        const seed = seedInput.value.trim();
        const reasoningEffort = model === 'openai-reasoning' ? document.getElementById('reasoning-effort').value : undefined;

        if (seed && !/^\d+$/.test(seed)) {
          showToast('Le seed doit être un nombre entier positif.', 'error');
          return;
        }

        currentPrompt = currentPrompt || prompt;
        isGenerating = true;

        document.getElementById('placeholder').style.display = 'none';

        if (!conversationHistory.some(msg => msg.role === 'user' && msg.content === prompt)) {
          conversationHistory.push({ role: 'user', content: prompt });
          addMessage('user', prompt);
        }
        promptInput.value = '';
        adjustTextareaHeight(promptInput);

        let messageContainer = null;
        try {
          const requestBody = {
            model: model,
            messages: [
              { role: 'system', content: systemPrompt },
              ...conversationHistory
            ],
            stream: true,
            seed: isRegenerate ? undefined : (seed ? parseInt(seed) : undefined),
            private: true
          };
          if (model === 'openai-reasoning') {
            requestBody.reasoning_effort = reasoningEffort;
          }
          if (isRegenerate) {
            requestBody.regenerate_timestamp = Date.now();
          }

          console.log('Requête envoyée:', JSON.stringify(requestBody));

          const response = await fetch('https://text.pollinations.ai/', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.error('Erreur API:', errorText);
            throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
          }

          const reader = response.body.getReader();
          let aiMessage = '';
          let contentFiltered = false;
          messageContainer = document.createElement('div');
          messageContainer.className = 'message-container';
          messageContainer.dataset.prompt = prompt;
          const messageDiv = document.createElement('div');
          messageDiv.className = 'message ai';
          messageContainer.appendChild(messageDiv);

          const actionsDiv = document.createElement('div');
          actionsDiv.className = 'message-actions ai';
          const regenerateBtn = document.createElement('button');
          regenerateBtn.className = 'regenerate-btn';
          regenerateBtn.innerHTML = '<i class="fas fa-redo"></i> Régénérer';
          regenerateBtn.addEventListener('click', () => regenerateResponse(messageContainer));
          actionsDiv.appendChild(regenerateBtn);
          messageContainer.appendChild(actionsDiv);

          chatMessages.appendChild(messageContainer);

          chunkBuffer = '';

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = new TextDecoder().decode(value);
            console.log('Chunk reçu:', chunk);
            chunkBuffer += chunk;

            const lines = chunkBuffer.split('\n');
            chunkBuffer = lines.pop() || '';

            for (const line of lines) {
              if (!line.startsWith('data: ')) continue;
              const data = line.slice(6);
              if (data === '[DONE]') break;

              try {
                const parsed = JSON.parse(data);
                if (
                  parsed.choices &&
                  parsed.choices.length > 0 &&
                  parsed.choices[0].delta &&
                  typeof parsed.choices[0].delta.content === 'string'
                ) {
                  const content = parsed.choices[0].delta.content;
                  aiMessage += content;
                  messageDiv.textContent = filterContent(aiMessage);
                  scrollToBottom();
                }
                if (parsed.choices && parsed.choices[0] && parsed.choices[0].finish_reason) {
                  if (parsed.choices[0].finish_reason === 'content_filter') {
                    contentFiltered = true;
                    break;
                  }
                  break;
                }
              } catch (e) {
                console.warn('Erreur lors du parsing du chunk:', e, 'Données:', data);
              }
            }
          }

          if (contentFiltered) {
            aiMessage = 'La réponse a été filtrée par l\'API en raison de restrictions de contenu.';
            messageDiv.textContent = aiMessage;
            conversationHistory.push({ role: 'ai', content: aiMessage });
            scrollToBottom();
            showToast('Contenu filtré par l\'API.', 'warning');
          } else if (!aiMessage) {
            throw new Error('Aucune réponse valide reçue de l\'API');
          } else {
            console.log('Réponse complète reçue:', aiMessage);
            currentText = aiMessage;
            conversationHistory.push({ role: 'ai', content: aiMessage });
            updateHistory(model, seed, reasoningEffort, systemPrompt, conversationHistory);
            showToast('Réponse générée avec succès !', 'success');
          }

          scrollToBottom();
          startCooldown();
        } catch (error) {
          console.error('Erreur:', error);
          if (messageContainer && messageContainer.parentNode) {
            messageContainer.parentNode.removeChild(messageContainer);
          }
          document.getElementById('placeholder').style.display = conversationHistory.length === 0 ? 'flex' : 'none';
          addMessage('ai', `Erreur: ${error.message}`);
          showToast(`Erreur: ${error.message}`, 'error', 5000);
          startCooldown();
        } finally {
          isGenerating = false;
          chunkBuffer = '';
          scrollToBottom();
        }
      }

      function updateHistory(model, seed, reasoningEffort, systemPrompt, messages) {
        console.log('updateHistory appelé');
        let history;
        try {
          history = JSON.parse(localStorage.getItem('textHistory') || '[]');
        } catch (e) {
          console.error('Erreur parsing textHistory:', e);
          history = [];
        }
        if (!currentConversationId) {
          currentConversationId = Date.now().toString() + Math.random().toString(36).slice(2);
          history.unshift({
            id: currentConversationId,
            model: model,
            seed: seed,
            reasoning_effort: reasoningEffort,
            systemPrompt: systemPrompt,
            messages: messages,
            timestamp: new Date().toISOString()
          });
        } else {
          const index = history.findIndex(h => h.id === currentConversationId);
          if (index !== -1) {
            history[index] = {
              id: currentConversationId,
              model: model,
              seed: seed,
              reasoning_effort: reasoningEffort,
              systemPrompt: systemPrompt,
              messages: messages,
              timestamp: new Date().toISOString()
            };
          }
        }
        if (history.length > 10) {
          history = history.slice(0, 10);
        }
        localStorage.setItem('textHistory', JSON.stringify(history));
        loadHistory();
      }

      loadHistory();
    });
  </script>
</body>
</html>
