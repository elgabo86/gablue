#!/bin/bash
INPUT="$1"    # %i
OUTPUT="$2"   # %o
SIZE="$3"     # %s (128 ou 256)

[ -z "$SIZE" ] && SIZE=256

# Script d'extraction d'icône Python (chemin relatif pour testing)
SCRIPT_DIR="$(dirname "$0")"
EXEICONEXTRACT="${SCRIPT_DIR}/../script/exeiconextract.py"

MAX_INSTANCES=3
PID_FILE="/tmp/wgp-thumbnailer-pids"
MY_PID=$$

# Petit délai pour laisser la copie commencer (si fichier vient d'être créé)
sleep 0.3

# Vérification de stabilité: le fichier doit avoir une taille stable
check_file_stable() {
    local file="$1"
    local timeout=2  # secondes max à attendre
    local elapsed=0
    local size1 size2

    size1=$(stat -c %s "$file" 2>/dev/null) || return 1

    while [ $elapsed -lt $timeout ]; do
        sleep 0.2
        size2=$(stat -c %s "$file" 2>/dev/null) || return 1

        # Si la taille a changé, le fichier est en cours d'écriture
        [ "$size1" = "$size2" ] && return 0
        size1=$size2
        elapsed=$((elapsed + 1))
    done

    return 1
}

# Vérifie que le fichier est stable avant de continuer
check_file_stable "$INPUT" || exit 1

# Sémaphore: attendre qu'une place soit libre puis enregistrer notre PID
acquire_slot() {
    local elapsed=0
    local timeout=30  # max 30 secondes d'attente (après ça abandonne)
    local count pids_to_keep

    while [ $elapsed -lt $timeout ]; do
        # Crée le fichier si n'existe pas
        [ -f "$PID_FILE" ] || touch "$PID_FILE"

        # Nettoyage des PIDs morts
        pids_to_keep=""
        while IFS= read -r pid || [ -n "$pid" ]; do
            [ -z "$pid" ] && continue
            # Vérifie si le PID est toujours vivant
            if kill -0 "$pid" 2>/dev/null; then
                pids_to_keep="${pids_to_keep}${pid}"$'\n'
            fi
        done < "$PID_FILE"
        echo "$pids_to_keep" > "$PID_FILE"

        # Compte les instances actives
        count=$(grep -c . "$PID_FILE" 2>/dev/null) || count=0

        if [ $count -lt $MAX_INSTANCES ]; then
            # Place libre: enregistre notre PID
            echo "$MY_PID" >> "$PID_FILE"
            return 0
        fi

        # Plus de place: attend un peu et réessaie
        sleep 0.2
        elapsed=$((elapsed + 1))
    done

    # Timeout atteint: abandonne
    return 1
}

# Libère notre slot du sémaphore
release_slot() {
    [ -f "$PID_FILE" ] || return 0
    local temp_file
    temp_file=$(mktemp)
    grep -vFx "$MY_PID" "$PID_FILE" > "$temp_file" 2>/dev/null
    mv "$temp_file" "$PID_FILE"
    # Nettoie le fichier si vide
    [ -s "$PID_FILE" ] || rm -f "$PID_FILE"
}

# Acquiert un slot ou quitte
acquire_slot || exit 1

TEMP_MOUNT=$(mktemp -d)
TEMP_ICO=$(mktemp -d)

# Nettoyage complet en toute circonstance
cleanup() {
    fusermount -u "$TEMP_MOUNT" 2>/dev/null
    rm -rf "$TEMP_MOUNT" "$TEMP_ICO"
    release_slot
}
trap cleanup EXIT

# Montage
squashfuse "$INPUT" "$TEMP_MOUNT" || exit 1

# L'icône custom .icon.png a priorité sur l'extraction depuis .exe
if [ -f "$TEMP_MOUNT/.icon.png" ]; then
    magick "$TEMP_MOUNT/.icon.png" -resize "${SIZE}x${SIZE}!" -background none -gravity center -extent "${SIZE}x${SIZE}" "$OUTPUT" 2>/dev/null && exit 0
fi

# Lecture .launch
if [ ! -f "$TEMP_MOUNT/.launch" ]; then
    exit 1  # → fallback MIME (org.gnome.Games)
fi

EXE_IN_WGP=$(cat "$TEMP_MOUNT/.launch" | tr -d '\r')
ICON_EXE_PATH="$TEMP_MOUNT/$EXE_IN_WGP"

# Si le fichier indiqué est un symlink → abandonne
[ -L "$ICON_EXE_PATH" ] && exit 1

# Si le fichier indiqué n'existe pas → fallback
[ -f "$ICON_EXE_PATH" ] || exit 1

# NOUVEAU : si c'est un .bat (ou .cmd, .ps1, etc.), on ne touche à rien → fallback
case "${ICON_EXE_PATH,,}" in  # ,, = tout en minuscule
    *.bat|*.cmd|*.ps1|*.vbs)
        exit 1  # → Dolphin affiche org.gnome.Games
        ;;
esac

# Sinon : c'est un .exe → extraction avec exeiconextract.py
TEMP_PNG="$TEMP_ICO/extracted.png"

python3 "$EXEICONEXTRACT" "$ICON_EXE_PATH" "$TEMP_PNG" 2>/dev/null
if [ -f "$TEMP_PNG" ]; then
    magick "$TEMP_PNG" -resize "${SIZE}x${SIZE}!" -background none -gravity center -extent "${SIZE}x${SIZE}" "$OUTPUT" 2>/dev/null && exit 0
fi

exit 1  # → fallback MIME si rien d'extrait
